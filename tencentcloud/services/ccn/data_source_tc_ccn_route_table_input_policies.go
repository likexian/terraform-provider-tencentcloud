// Code generated by iacg; DO NOT EDIT.
package ccn

import (
	"context"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	vpcv20170312 "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/vpc/v20170312"
	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
	"strings"
)

func DataSourceTencentCloudCcnRouteTableInputPolicies() *schema.Resource {
	return &schema.Resource{
		Read: dataSourceTencentCloudCcnRouteTableInputPoliciesRead,
		Schema: map[string]*schema.Schema{
			"ccn_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "CCN Instance ID.",
			},

			"route_table_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "CCN Route table ID.",
			},

			"policy_version": {
				Type:        schema.TypeInt,
				Optional:    true,
				Description: "Policy version.",
			},

			"policy_set": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: "Policy set.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"policys": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: "Policys.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"route_conditions": {
										Type:        schema.TypeList,
										Required:    true,
										Description: "Routing conditions.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"name": {
													Type:        schema.TypeString,
													Required:    true,
													Description: "condition type.",
												},
												"values": {
													Type:        schema.TypeSet,
													Required:    true,
													Description: "List of conditional values.",
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
												"match_pattern": {
													Type:        schema.TypeInt,
													Required:    true,
													Description: "Matching mode, `1` precise matching, `0` fuzzy matching.",
												},
											},
										},
									},
									"action": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Routing behavior, `accept` allows, `drop` rejects.",
									},
									"description": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Policy description",
									},
									"operate_as_path": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "as-path operate",
									},
									"as_path_operate_mode": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "as-path operate mode",
									},
								},
							},
						},
						"policy_version": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "Policy version.",
						},
						"create_time": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Create time.",
						},
					},
				},
			},

			"result_output_file": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Used to save results.",
			},
		},
	}
}

func dataSourceTencentCloudCcnRouteTableInputPoliciesRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("data_source.tencentcloud_ccn_route_table_input_policies.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(nil)
	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	service := VpcService{client: meta.(tccommon.ProviderMeta).GetAPIV3Conn()}

	var (
		ccnId        string
		routeTableId string
	)
	if v, ok := d.GetOk("ccn_id"); ok {
		ccnId = v.(string)
	}
	if v, ok := d.GetOk("route_table_id"); ok {
		routeTableId = v.(string)
	}
	paramMap := make(map[string]interface{})
	if v, ok := d.GetOk("ccn_id"); ok {
		paramMap["CcnId"] = helper.String(v.(string))
	}

	if v, ok := d.GetOk("route_table_id"); ok {
		paramMap["RouteTableId"] = helper.String(v.(string))
	}

	if v, ok := d.GetOkExists("policy_version"); ok {
		paramMap["PolicyVersion"] = helper.IntUint64(v.(int))
	}

	var respData []*vpcv20170312.CcnRouteTableInputPolicys
	err := resource.Retry(tccommon.ReadRetryTimeout, func() *resource.RetryError {
		result, e := service.DescribeCcnRouteTableInputPoliciesByFilter(ctx, paramMap)
		if e != nil {
			return tccommon.RetryError(e)
		}
		respData = result
		return nil
	})
	if err != nil {
		return err
	}

	policySetList := make([]map[string]interface{}, 0, len(respData))
	if respData != nil {
		for _, policySet := range respData {
			policySetMap := map[string]interface{}{}

			policysList := make([]map[string]interface{}, 0, len(policySet.Policys))
			if policySet.Policys != nil {
				for _, policys := range policySet.Policys {
					policysMap := map[string]interface{}{}

					routeConditionsList := make([]map[string]interface{}, 0, len(policys.RouteConditions))
					if policys.RouteConditions != nil {
						for _, routeConditions := range policys.RouteConditions {
							routeConditionsMap := map[string]interface{}{}

							if routeConditions.Name != nil {
								routeConditionsMap["name"] = routeConditions.Name
							}

							if routeConditions.Values != nil {
								routeConditionsMap["values"] = routeConditions.Values
							}

							if routeConditions.MatchPattern != nil {
								routeConditionsMap["match_pattern"] = routeConditions.MatchPattern
							}

							routeConditionsList = append(routeConditionsList, routeConditionsMap)
						}

						policysMap["route_conditions"] = routeConditionsList
					}
					if policys.Action != nil {
						policysMap["action"] = policys.Action
					}

					if policys.Description != nil {
						policysMap["description"] = policys.Description
					}

					if policys.OperateAsPath != nil {
						policysMap["operate_as_path"] = policys.OperateAsPath
					}

					if policys.AsPathOperateMode != nil {
						policysMap["as_path_operate_mode"] = policys.AsPathOperateMode
					}

					policysList = append(policysList, policysMap)
				}

				policySetMap["policys"] = policysList
			}
			if policySet.PolicyVersion != nil {
				policySetMap["policy_version"] = policySet.PolicyVersion
			}

			if policySet.CreateTime != nil {
				policySetMap["create_time"] = policySet.CreateTime
			}

			policySetList = append(policySetList, policySetMap)
		}

		_ = d.Set("policy_set", policySetList)
	}

	d.SetId(strings.Join([]string{ccnId, routeTableId}, tccommon.FILED_SP))

	output, ok := d.GetOk("result_output_file")
	if ok && output.(string) != "" {
		if e := tccommon.WriteToFile(output.(string), policySetList); e != nil {
			return e
		}
	}

	return nil
}
