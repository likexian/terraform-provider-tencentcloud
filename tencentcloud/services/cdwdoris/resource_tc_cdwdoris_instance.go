// Code generated by iacg; DO NOT EDIT.
package cdwdoris

import (
	"context"
	"fmt"
	"log"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	cdwdorisv20211228 "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/cdwdoris/v20211228"

	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
)

func ResourceTencentCloudCdwdorisInstance() *schema.Resource {
	return &schema.Resource{
		Create: resourceTencentCloudCdwdorisInstanceCreate,
		Read:   resourceTencentCloudCdwdorisInstanceRead,
		Update: resourceTencentCloudCdwdorisInstanceUpdate,
		Delete: resourceTencentCloudCdwdorisInstanceDelete,
		Schema: map[string]*schema.Schema{
			"zone": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Availability zone.",
			},
			"fe_spec": {
				Type:        schema.TypeList,
				Required:    true,
				MaxItems:    1,
				Description: "FE specifications.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"spec_name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Specification name.",
						},
						"count": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "Quantities.",
						},
						"disk_size": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "Cloud disk size.",
						},
					},
				},
			},
			"be_spec": {
				Type:        schema.TypeList,
				Required:    true,
				MaxItems:    1,
				Description: "BE specifications.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"spec_name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Specification name.",
						},
						"count": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "Quantities.",
						},
						"disk_size": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "Cloud disk size.",
						},
					},
				},
			},
			"ha_flag": {
				Type:        schema.TypeBool,
				Required:    true,
				Description: "Whether it is highly available.",
			},
			"user_vpc_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "User VPCID.",
			},
			"user_subnet_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "User subnet ID.",
			},
			"product_version": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Product version number.",
			},
			"charge_properties": {
				Type:        schema.TypeList,
				Required:    true,
				MaxItems:    1,
				Description: "Payment type.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"charge_type": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: tccommon.ValidateAllowedStringValue(CHARGE_TYPE),
							Description:  "Billing type: `PREPAID` for prepayment, and `POSTPAID_BY_HOUR` for postpayment. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"renew_flag": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "Whether to automatically renew. 1 means automatic renewal is enabled. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"time_span": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "Billing duration Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"time_unit": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Billing time unit, and `m` means month, etc. Note: This field may return null, indicating that no valid values can be obtained.",
						},
					},
				},
			},
			"instance_name": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Instance name.",
			},
			"doris_user_pwd": {
				Type:        schema.TypeString,
				Required:    true,
				Sensitive:   true,
				Description: "Database password.",
			},
			"tags": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "Tag list.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"tag_key": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Tag key.",
						},
						"tag_value": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Tag value.",
						},
					},
				},
			},
			"ha_type": {
				Type:        schema.TypeInt,
				Optional:    true,
				Description: "High availability type: 0 indicates non-high availability (only one FE, FeSpec.CreateInstanceSpec.Count=1), 1 indicates read high availability (at least 3 FEs must be deployed, FeSpec.CreateInstanceSpec.Count>=3, and it must be an odd number), 2 indicates read and write high availability (at least 5 FEs must be deployed, FeSpec.CreateInstanceSpec.Count>=5, and it must be an odd number).",
			},
			"case_sensitive": {
				Type:        schema.TypeInt,
				Optional:    true,
				Description: "Whether the table name is case sensitive, 0 refers to sensitive, 1 refers to insensitive, compared in lowercase; 2 refers to insensitive, and the table name is changed to lowercase for storage.",
			},
			"enable_multi_zones": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: "Whether to enable multi-availability zone.",
			},
			"user_multi_zone_infos": {
				Type:        schema.TypeList,
				Optional:    true,
				MaxItems:    1,
				Description: "After the Multi-AZ is enabled, all user's Availability Zones and Subnets information are shown.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"zone": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Availability zone Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"subnet_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Subnet ID Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"subnet_ip_num": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The number of available IP addresses in the current subnet Note: This field may return null, indicating that no valid values can be obtained.",
						},
					},
				},
			},
			"security_group_ids": {
				Type:        schema.TypeList,
				Optional:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
				Description: "Security Group Id list.",
			},
			"workload_group_status": {
				Type:         schema.TypeString,
				Required:     true,
				ValidateFunc: tccommon.ValidateAllowedStringValue(WORKLOAD_GROUP_STATUS),
				Description:  "Whether to enable resource group. `open` - enable, `close` - disable.",
			},
		},
	}
}

func resourceTencentCloudCdwdorisInstanceCreate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_cdwdoris_instance.create")()
	defer tccommon.InconsistentCheck(d, meta)()

	var (
		logId               = tccommon.GetLogId(tccommon.ContextNil)
		ctx                 = tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)
		request             = cdwdorisv20211228.NewCreateInstanceNewRequest()
		response            = cdwdorisv20211228.NewCreateInstanceNewResponse()
		instanceId          string
		workloadGroupStatus string
	)

	if v, ok := d.GetOk("zone"); ok {
		request.Zone = helper.String(v.(string))
	}

	if feSpecMap, ok := helper.InterfacesHeadMap(d, "fe_spec"); ok {
		createInstanceSpec := cdwdorisv20211228.CreateInstanceSpec{}
		if v, ok := feSpecMap["spec_name"]; ok {
			createInstanceSpec.SpecName = helper.String(v.(string))
		}

		if v, ok := feSpecMap["count"]; ok {
			createInstanceSpec.Count = helper.IntUint64(v.(int))
		}

		if v, ok := feSpecMap["disk_size"]; ok {
			createInstanceSpec.DiskSize = helper.IntUint64(v.(int))
		}

		request.FeSpec = &createInstanceSpec
	}

	if beSpecMap, ok := helper.InterfacesHeadMap(d, "be_spec"); ok {
		createInstanceSpec2 := cdwdorisv20211228.CreateInstanceSpec{}
		if v, ok := beSpecMap["spec_name"]; ok {
			createInstanceSpec2.SpecName = helper.String(v.(string))
		}

		if v, ok := beSpecMap["count"]; ok {
			createInstanceSpec2.Count = helper.IntUint64(v.(int))
		}

		if v, ok := beSpecMap["disk_size"]; ok {
			createInstanceSpec2.DiskSize = helper.IntUint64(v.(int))
		}

		request.BeSpec = &createInstanceSpec2
	}

	if v, ok := d.GetOkExists("ha_flag"); ok {
		request.HaFlag = helper.Bool(v.(bool))
	}

	if v, ok := d.GetOk("user_vpc_id"); ok {
		request.UserVPCId = helper.String(v.(string))
	}

	if v, ok := d.GetOk("user_subnet_id"); ok {
		request.UserSubnetId = helper.String(v.(string))
	}

	if v, ok := d.GetOk("product_version"); ok {
		request.ProductVersion = helper.String(v.(string))
	}

	if chargePropertiesMap, ok := helper.InterfacesHeadMap(d, "charge_properties"); ok {
		chargeProperties := cdwdorisv20211228.ChargeProperties{}
		if v, ok := chargePropertiesMap["charge_type"]; ok {
			chargeProperties.ChargeType = helper.String(v.(string))
		}

		if v, ok := chargePropertiesMap["renew_flag"]; ok {
			chargeProperties.RenewFlag = helper.IntInt64(v.(int))
		}

		if v, ok := chargePropertiesMap["time_span"]; ok {
			chargeProperties.TimeSpan = helper.IntInt64(v.(int))
		}

		if v, ok := chargePropertiesMap["time_unit"]; ok {
			chargeProperties.TimeUnit = helper.String(v.(string))
		}

		request.ChargeProperties = &chargeProperties
	}

	if v, ok := d.GetOk("instance_name"); ok {
		request.InstanceName = helper.String(v.(string))
	}

	if v, ok := d.GetOk("doris_user_pwd"); ok {
		request.DorisUserPwd = helper.String(v.(string))
	}

	if v, ok := d.GetOk("tags"); ok {
		for _, item := range v.([]interface{}) {
			tagsMap := item.(map[string]interface{})
			tag := cdwdorisv20211228.Tag{}
			if v, ok := tagsMap["tag_key"]; ok {
				tag.TagKey = helper.String(v.(string))
			}

			if v, ok := tagsMap["tag_value"]; ok {
				tag.TagValue = helper.String(v.(string))
			}

			request.Tags = append(request.Tags, &tag)
		}
	}

	if v, ok := d.GetOkExists("ha_type"); ok {
		request.HaType = helper.IntInt64(v.(int))
	}

	if v, ok := d.GetOkExists("case_sensitive"); ok {
		request.CaseSensitive = helper.IntInt64(v.(int))
	}

	if v, ok := d.GetOkExists("enable_multi_zones"); ok {
		request.EnableMultiZones = helper.Bool(v.(bool))
	}

	if userMultiZoneInfosMap, ok := helper.InterfacesHeadMap(d, "user_multi_zone_infos"); ok {
		networkInfo := cdwdorisv20211228.NetworkInfo{}
		if v, ok := userMultiZoneInfosMap["zone"]; ok {
			networkInfo.Zone = helper.String(v.(string))
		}

		if v, ok := userMultiZoneInfosMap["subnet_id"]; ok {
			networkInfo.SubnetId = helper.String(v.(string))
		}

		if v, ok := userMultiZoneInfosMap["subnet_ip_num"]; ok {
			networkInfo.SubnetIpNum = helper.IntInt64(v.(int))
		}

		request.UserMultiZoneInfos = &networkInfo
	}

	err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCdwdorisV20211228Client().CreateInstanceNewWithContext(ctx, request)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s] ", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
		}

		response = result
		return nil
	})

	if err != nil {
		log.Printf("[CRITAL]%s create cdwdoris instance failed, reason:%+v", logId, err)
		return err
	}

	instanceId = *response.Response.InstanceId
	d.SetId(instanceId)

	// wait
	waitRequest := cdwdorisv20211228.NewDescribeInstanceStateRequest()
	waitRequest.InstanceId = &instanceId
	err = resource.Retry(tccommon.ReadRetryTimeout*10, func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCdwdorisV20211228Client().DescribeInstanceStateWithContext(ctx, waitRequest)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s] ", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
		}

		if *result.Response.InstanceState != INSTANCE_STATE_SERVING {
			return resource.RetryableError(fmt.Errorf("instance status is %s, retry...", *result.Response.InstanceState))
		}

		return nil
	})

	if err != nil {
		log.Printf("[CRITAL]%s create cdwdoris instance failed, reason:%+v", logId, err)
		return err
	}

	if v, ok := d.GetOk("security_group_ids"); ok {
		securityGroupIds := v.([]interface{})
		tmpList := make([]*string, 0, len(securityGroupIds))
		for _, item := range securityGroupIds {
			securityGroupId := item.(string)
			tmpList = append(tmpList, &securityGroupId)
		}

		sgRequest := cdwdorisv20211228.NewModifySecurityGroupsRequest()
		sgRequest.InstanceId = &instanceId
		sgRequest.ModifySecurityGroupIds = tmpList
		err = resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCdwdorisV20211228Client().ModifySecurityGroupsWithContext(ctx, sgRequest)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s] ", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
			}

			return nil
		})

		if err != nil {
			log.Printf("[CRITAL]%s modify cdwdoris Security Groups failed, reason:%+v", logId, err)
			return err
		}
	}

	if v, ok := d.GetOk("workload_group_status"); ok {
		workloadGroupStatus = v.(string)
		if workloadGroupStatus == WORKLOAD_GROUP_STATUS_OPEN {
			workloadGroupStatusRequest := cdwdorisv20211228.NewModifyWorkloadGroupStatusRequest()
			workloadGroupStatusRequest.InstanceId = &instanceId
			workloadGroupStatusRequest.OperationType = &workloadGroupStatus
			err = resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
				result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCdwdorisV20211228Client().ModifyWorkloadGroupStatusWithContext(ctx, workloadGroupStatusRequest)
				if e != nil {
					return tccommon.RetryError(e)
				} else {
					log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s] ", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
				}

				return nil
			})

			if err != nil {
				log.Printf("[CRITAL]%s modify cdwdoris instance workload group status failed, reason:%+v", logId, err)
				return err
			}

			// wait
			err = resource.Retry(tccommon.ReadRetryTimeout*10, func() *resource.RetryError {
				result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCdwdorisV20211228Client().DescribeInstanceStateWithContext(ctx, waitRequest)
				if e != nil {
					return tccommon.RetryError(e)
				} else {
					log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s] ", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
				}

				if *result.Response.InstanceState != INSTANCE_STATE_SERVING {
					return resource.RetryableError(fmt.Errorf("instance status is %s, retry...", *result.Response.InstanceState))
				}

				return nil
			})

			if err != nil {
				log.Printf("[CRITAL]%s modify cdwdoris instance workload group status failed, reason:%+v", logId, err)
				return err
			}
		}
	}

	return resourceTencentCloudCdwdorisInstanceRead(d, meta)
}

func resourceTencentCloudCdwdorisInstanceRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_cdwdoris_instance.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	var (
		logId      = tccommon.GetLogId(tccommon.ContextNil)
		ctx        = tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)
		service    = CdwdorisService{client: meta.(tccommon.ProviderMeta).GetAPIV3Conn()}
		instanceId = d.Id()
	)

	respData, err := service.DescribeCdwdorisInstanceById(ctx, instanceId)
	if err != nil {
		return err
	}

	if respData == nil {
		d.SetId("")
		log.Printf("[WARN]%s resource `cdwdoris_instance` [%s] not found, please check if it has been deleted.", logId, d.Id())
		return nil
	}

	if respData.InstanceName != nil {
		_ = d.Set("instance_name", respData.InstanceName)
	}

	if respData.Version != nil {
		_ = d.Set("product_version", respData.Version)
	}

	if respData.Zone != nil {
		_ = d.Set("zone", respData.Zone)
	}

	if respData.VpcId != nil {
		_ = d.Set("user_vpc_id", respData.VpcId)
	}

	if respData.SubnetId != nil {
		_ = d.Set("user_subnet_id", respData.SubnetId)
	}

	if respData.MasterSummary != nil {
		masterSummaryMap := map[string]interface{}{}
		if respData.MasterSummary.Spec != nil {
			masterSummaryMap["spec_name"] = respData.MasterSummary.Spec
		}

		if respData.MasterSummary.NodeSize != nil {
			masterSummaryMap["count"] = respData.MasterSummary.NodeSize
		}

		if respData.MasterSummary.Disk != nil {
			masterSummaryMap["disk_size"] = respData.MasterSummary.Disk
		}

		_ = d.Set("fe_spec", []interface{}{masterSummaryMap})
	}

	if respData.CoreSummary != nil {
		coreSummaryMap := map[string]interface{}{}
		if respData.CoreSummary.Spec != nil {
			coreSummaryMap["spec_name"] = respData.CoreSummary.Spec
		}

		if respData.CoreSummary.NodeSize != nil {
			coreSummaryMap["count"] = respData.CoreSummary.NodeSize
		}

		if respData.CoreSummary.Disk != nil {
			coreSummaryMap["disk_size"] = respData.CoreSummary.Disk
		}

		_ = d.Set("be_spec", []interface{}{coreSummaryMap})
	}

	if respData.HA != nil {
		if *respData.HA == "true" {
			_ = d.Set("ha_flag", true)
		} else {
			_ = d.Set("ha_flag", false)
		}
	}

	if respData.HaType != nil {
		_ = d.Set("ha_type", respData.HaType)
	}

	if respData.Tags != nil {
		tagsList := make([]map[string]interface{}, 0, len(respData.Tags))
		for _, tags := range respData.Tags {
			tagsMap := map[string]interface{}{}
			if tags.TagKey != nil {
				tagsMap["tag_key"] = tags.TagKey
			}

			if tags.TagValue != nil {
				tagsMap["tag_value"] = tags.TagValue
			}

			tagsList = append(tagsList, tagsMap)
		}

		_ = d.Set("tags", tagsList)
	}

	if respData.BindSGs != nil {
		tmpList := make([]string, 0, len(respData.BindSGs))
		for _, item := range respData.BindSGs {
			tmpList = append(tmpList, *item)
		}

		_ = d.Set("security_group_ids", tmpList)
	}

	respData1, err := service.DescribeCdwdorisWorkloadGroupsById(ctx, instanceId)
	if err != nil {
		return err
	}

	if respData1 == nil {
		d.SetId("")
		log.Printf("[WARN]%s resource `cdwdoris_workload_group` [%s] not found, please check if it has been deleted.", logId, d.Id())
		return nil
	}

	if respData1.Status != nil {
		_ = d.Set("workload_group_status", respData1.Status)
	}

	return nil
}

func resourceTencentCloudCdwdorisInstanceUpdate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_cdwdoris_instance.update")()
	defer tccommon.InconsistentCheck(d, meta)()

	var (
		logId      = tccommon.GetLogId(tccommon.ContextNil)
		ctx        = tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)
		instanceId = d.Id()
	)

	immutableArgs := []string{"zone", "fe_spec", "be_spec", "ha_flag", "user_vpc_id", "user_subnet_id", "product_version", "charge_type", "charge_properties", "doris_user_pwd", "tags", "case_sensitive", "enable_multi_zones", "user_multi_zone_infos"}
	for _, v := range immutableArgs {
		if d.HasChange(v) {
			return fmt.Errorf("argument `%s` cannot be changed", v)
		}
	}

	if d.HasChange("instance_name") {
		request := cdwdorisv20211228.NewModifyInstanceRequest()
		request.InstanceId = &instanceId
		if v, ok := d.GetOk("instance_name"); ok {
			request.InstanceName = helper.String(v.(string))
		}

		err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCdwdorisV20211228Client().ModifyInstanceWithContext(ctx, request)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s] ", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
			}

			return nil
		})

		if err != nil {
			log.Printf("[CRITAL]%s update cdwdoris instance instance_name failed, reason:%+v", logId, err)
			return err
		}
	}

	if d.HasChange("security_group_ids") {
		oldValue, newValue := d.GetChange("security_group_ids")
		oldSecurityGroupIds := oldValue.([]interface{})
		newSecurityGroupIds := newValue.([]interface{})
		tmpOld := make([]*string, 0, len(oldSecurityGroupIds))
		tmpNew := make([]*string, 0, len(newSecurityGroupIds))
		for _, item := range oldSecurityGroupIds {
			securityGroupId := item.(string)
			tmpOld = append(tmpOld, &securityGroupId)
		}

		for _, item := range newSecurityGroupIds {
			securityGroupId := item.(string)
			tmpNew = append(tmpNew, &securityGroupId)
		}

		request := cdwdorisv20211228.NewModifySecurityGroupsRequest()
		request.InstanceId = &instanceId
		request.OldSecurityGroupIds = tmpOld
		request.ModifySecurityGroupIds = tmpNew
		err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCdwdorisV20211228Client().ModifySecurityGroupsWithContext(ctx, request)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s] ", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
			}

			return nil
		})

		if err != nil {
			log.Printf("[CRITAL]%s modify cdwdoris Security Groups failed, reason:%+v", logId, err)
			return err
		}
	}

	if d.HasChange("workload_group_status") {
		workloadGroupStatus := d.Get("workload_group_status").(string)
		request := cdwdorisv20211228.NewModifyWorkloadGroupStatusRequest()
		request.InstanceId = &instanceId
		request.OperationType = &workloadGroupStatus
		err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCdwdorisV20211228Client().ModifyWorkloadGroupStatusWithContext(ctx, request)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s] ", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
			}

			return nil
		})

		if err != nil {
			log.Printf("[CRITAL]%s modify cdwdoris instance workload group status failed, reason:%+v", logId, err)
			return err
		}

		// wait
		waitRequest := cdwdorisv20211228.NewDescribeInstanceStateRequest()
		waitRequest.InstanceId = &instanceId
		err = resource.Retry(tccommon.ReadRetryTimeout*10, func() *resource.RetryError {
			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCdwdorisV20211228Client().DescribeInstanceStateWithContext(ctx, waitRequest)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s] ", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
			}

			if *result.Response.InstanceState != INSTANCE_STATE_SERVING {
				return resource.RetryableError(fmt.Errorf("instance status is %s, retry...", *result.Response.InstanceState))
			}

			return nil
		})

		if err != nil {
			log.Printf("[CRITAL]%s modify cdwdoris instance workload group status failed, reason:%+v", logId, err)
			return err
		}
	}

	return resourceTencentCloudCdwdorisInstanceRead(d, meta)
}

func resourceTencentCloudCdwdorisInstanceDelete(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_cdwdoris_instance.delete")()
	defer tccommon.InconsistentCheck(d, meta)()

	var (
		logId      = tccommon.GetLogId(tccommon.ContextNil)
		ctx        = tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)
		request    = cdwdorisv20211228.NewDestroyInstanceRequest()
		instanceId = d.Id()
		chargeType string
	)

	if chargePropertiesMap, ok := helper.InterfacesHeadMap(d, "charge_properties"); ok {
		if v, ok := chargePropertiesMap["charge_type"]; ok {
			chargeType = v.(string)
		}
	}

	request.InstanceId = &instanceId
	err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCdwdorisV20211228Client().DestroyInstanceWithContext(ctx, request)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s] ", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
		}

		return nil
	})

	if err != nil {
		log.Printf("[CRITAL]%s delete cdwdoris instance failed, reason:%+v", logId, err)
		return err
	}

	// wait
	describeRequest := cdwdorisv20211228.NewDescribeInstancesRequest()
	describeRequest.SearchInstanceId = helper.String(instanceId)
	if chargeType == CHARGE_TYPE_POSTPAID_BY_HOUR {
		err = resource.Retry(tccommon.ReadRetryTimeout*5, func() *resource.RetryError {
			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCdwdorisV20211228Client().DescribeInstancesWithContext(ctx, describeRequest)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s] ", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
			}

			if len(result.Response.InstancesList) != 0 {
				instanceState := result.Response.InstancesList[0].Status
				return resource.RetryableError(fmt.Errorf("instance status is %s, retry...", *instanceState))
			}

			return nil
		})

		if err != nil {
			log.Printf("[CRITAL]%s delete cdwdoris instance failed, reason:%+v", logId, err)
			return err
		}
	} else {
		waitRequest := cdwdorisv20211228.NewDescribeInstanceStateRequest()
		waitRequest.InstanceId = &instanceId
		err = resource.Retry(tccommon.ReadRetryTimeout*5, func() *resource.RetryError {
			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCdwdorisV20211228Client().DescribeInstanceStateWithContext(ctx, waitRequest)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s] ", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
			}

			if *result.Response.InstanceState != INSTANCE_STATE_ISOLATED {
				return resource.RetryableError(fmt.Errorf("instance status is %s, retry...", *result.Response.InstanceState))
			}

			return nil
		})

		if err != nil {
			log.Printf("[CRITAL]%s delete cdwdoris instance failed, reason:%+v", logId, err)
			return err
		}

		// prepaid need delete again
		if chargeType == CHARGE_TYPE_PREPAID {
			err = resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
				result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCdwdorisV20211228Client().DestroyInstanceWithContext(ctx, request)
				if e != nil {
					return tccommon.RetryError(e)
				} else {
					log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s] ", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
				}

				return nil
			})

			if err != nil {
				log.Printf("[CRITAL]%s delete cdwdoris instance failed, reason:%+v", logId, err)
				return err
			}

			err = resource.Retry(tccommon.ReadRetryTimeout*5, func() *resource.RetryError {
				result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCdwdorisV20211228Client().DescribeInstancesWithContext(ctx, describeRequest)
				if e != nil {
					return tccommon.RetryError(e)
				} else {
					log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s] ", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
				}

				if len(result.Response.InstancesList) != 0 {
					instanceState := result.Response.InstancesList[0].Status
					return resource.RetryableError(fmt.Errorf("instance status is %s, retry...", *instanceState))
				}

				return nil
			})

			if err != nil {
				log.Printf("[CRITAL]%s delete cdwdoris instance failed, reason:%+v", logId, err)
				return err
			}
		}
	}

	return nil
}
