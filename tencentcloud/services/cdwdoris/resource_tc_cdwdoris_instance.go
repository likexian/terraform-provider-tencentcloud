// Code generated by iacg; DO NOT EDIT.
package cdwdoris

import (
	"context"
	"fmt"
	"log"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	cdwdorisv20211228 "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/cdwdoris/v20211228"

	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
)

func ResourceTencentCloudCdwdorisInstance() *schema.Resource {
	return &schema.Resource{
		Create: resourceTencentCloudCdwdorisInstanceCreate,
		Read:   resourceTencentCloudCdwdorisInstanceRead,
		Update: resourceTencentCloudCdwdorisInstanceUpdate,
		Delete: resourceTencentCloudCdwdorisInstanceDelete,
		Schema: map[string]*schema.Schema{
			"zone": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Availability zone",
			},

			"fe_spec": {
				Type:        schema.TypeList,
				Required:    true,
				MaxItems:    1,
				Description: "FE specifications",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"spec_name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Specification name",
						},
						"count": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "Quantities",
						},
						"disk_size": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "Cloud disk size",
						},
					},
				},
			},

			"be_spec": {
				Type:        schema.TypeList,
				Required:    true,
				MaxItems:    1,
				Description: "BE specifications.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"spec_name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Specification name",
						},
						"count": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "Quantities",
						},
						"disk_size": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "Cloud disk size",
						},
					},
				},
			},

			"ha_flag": {
				Type:        schema.TypeBool,
				Required:    true,
				Description: "Whether it is highly available.",
			},

			"user_vpc_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "User VPCID",
			},

			"user_subnet_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "User subnet ID",
			},

			"product_version": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Product version number",
			},

			"charge_properties": {
				Type:        schema.TypeList,
				Required:    true,
				MaxItems:    1,
				Description: "Payment type",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"charge_type": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Billing type: PREPAID for prepayment, and POSTPAID_BY_HOUR for postpayment.\nNote: This field may return null, indicating that no valid values can be obtained.",
						},
						"renew_flag": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "Whether to automatically renew. 1 means automatic renewal is enabled.\nNote: This field may return null, indicating that no valid values can be obtained.",
						},
						"time_span": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "Billing duration\nNote: This field may return null, indicating that no valid values can be obtained.",
						},
						"time_unit": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Billing time unit, and \"m\" means month, etc.\nNote: This field may return null, indicating that no valid values can be obtained.",
						},
					},
				},
			},

			"instance_name": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Instance name",
			},

			"doris_user_pwd": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Database password",
			},

			"tags": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "Tag list",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"tag_key": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Tag key",
						},
						"tag_value": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Tag value",
						},
					},
				},
			},

			"ha_type": {
				Type:        schema.TypeInt,
				Optional:    true,
				Description: "High availability type:\n0 indicates non-high availability (only one FE, FeSpec.CreateInstanceSpec.Count=1),\n1 indicates read high availability (at least 3 FEs must be deployed, FeSpec.CreateInstanceSpec.Count>=3, and it must be an odd number),\n2 indicates read and write high availability (at least 5 FEs must be deployed, FeSpec.CreateInstanceSpec.Count>=5, and it must be an odd number).",
			},

			"case_sensitive": {
				Type:        schema.TypeInt,
				Optional:    true,
				Description: "Whether the table name is case sensitive, 0 refers to sensitive, 1 refers to insensitive, compared in lowercase; 2 refers to insensitive, and the table name is changed to lowercase for storage.",
			},

			"enable_multi_zones": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: "Whether to enable multi-availability zone.",
			},

			"user_multi_zone_infos": {
				Type:        schema.TypeList,
				Optional:    true,
				MaxItems:    1,
				Description: "After the Multi-AZ is enabled, all user's Availability Zones and Subnets information are shown.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"zone": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Availability zone\nNote: This field may return null, indicating that no valid values can be obtained.",
						},
						"subnet_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Subnet ID\nNote: This field may return null, indicating that no valid values can be obtained.",
						},
						"subnet_ip_num": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The number of available IP addresses in the current subnet\nNote: This field may return null, indicating that no valid values can be obtained.",
						},
					},
				},
			},
		},
	}
}

func resourceTencentCloudCdwdorisInstanceCreate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_cdwdoris_instance.create")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	var (
		instanceId string
	)
	var (
		request  = cdwdorisv20211228.NewCreateInstanceNewRequest()
		response = cdwdorisv20211228.NewCreateInstanceNewResponse()
	)

	if v, ok := d.GetOk("zone"); ok {
		request.Zone = helper.String(v.(string))
	}

	if feSpecMap, ok := helper.InterfacesHeadMap(d, "fe_spec"); ok {
		createInstanceSpec := cdwdorisv20211228.CreateInstanceSpec{}
		if v, ok := feSpecMap["spec_name"]; ok {
			createInstanceSpec.SpecName = helper.String(v.(string))
		}
		if v, ok := feSpecMap["count"]; ok {
			createInstanceSpec.Count = helper.IntUint64(v.(int))
		}
		if v, ok := feSpecMap["disk_size"]; ok {
			createInstanceSpec.DiskSize = helper.IntUint64(v.(int))
		}
		request.FeSpec = &createInstanceSpec
	}

	if beSpecMap, ok := helper.InterfacesHeadMap(d, "be_spec"); ok {
		createInstanceSpec2 := cdwdorisv20211228.CreateInstanceSpec{}
		if v, ok := beSpecMap["spec_name"]; ok {
			createInstanceSpec2.SpecName = helper.String(v.(string))
		}
		if v, ok := beSpecMap["count"]; ok {
			createInstanceSpec2.Count = helper.IntUint64(v.(int))
		}
		if v, ok := beSpecMap["disk_size"]; ok {
			createInstanceSpec2.DiskSize = helper.IntUint64(v.(int))
		}
		request.BeSpec = &createInstanceSpec2
	}

	if v, ok := d.GetOkExists("ha_flag"); ok {
		request.HaFlag = helper.Bool(v.(bool))
	}

	if v, ok := d.GetOk("user_vpc_id"); ok {
		request.UserVPCId = helper.String(v.(string))
	}

	if v, ok := d.GetOk("user_subnet_id"); ok {
		request.UserSubnetId = helper.String(v.(string))
	}

	if v, ok := d.GetOk("product_version"); ok {
		request.ProductVersion = helper.String(v.(string))
	}

	if chargePropertiesMap, ok := helper.InterfacesHeadMap(d, "charge_properties"); ok {
		chargeProperties := cdwdorisv20211228.ChargeProperties{}
		if v, ok := chargePropertiesMap["charge_type"]; ok {
			chargeProperties.ChargeType = helper.String(v.(string))
		}
		if v, ok := chargePropertiesMap["renew_flag"]; ok {
			chargeProperties.RenewFlag = helper.IntInt64(v.(int))
		}
		if v, ok := chargePropertiesMap["time_span"]; ok {
			chargeProperties.TimeSpan = helper.IntInt64(v.(int))
		}
		if v, ok := chargePropertiesMap["time_unit"]; ok {
			chargeProperties.TimeUnit = helper.String(v.(string))
		}
		request.ChargeProperties = &chargeProperties
	}

	if v, ok := d.GetOk("instance_name"); ok {
		request.InstanceName = helper.String(v.(string))
	}

	if v, ok := d.GetOk("doris_user_pwd"); ok {
		request.DorisUserPwd = helper.String(v.(string))
	}

	if v, ok := d.GetOk("tags"); ok {
		for _, item := range v.([]interface{}) {
			tagsMap := item.(map[string]interface{})
			tag := cdwdorisv20211228.Tag{}
			if v, ok := tagsMap["tag_key"]; ok {
				tag.TagKey = helper.String(v.(string))
			}
			if v, ok := tagsMap["tag_value"]; ok {
				tag.TagValue = helper.String(v.(string))
			}
			request.Tags = append(request.Tags, &tag)
		}
	}

	if v, ok := d.GetOkExists("ha_type"); ok {
		request.HaType = helper.IntInt64(v.(int))
	}

	if v, ok := d.GetOkExists("case_sensitive"); ok {
		request.CaseSensitive = helper.IntInt64(v.(int))
	}

	if v, ok := d.GetOkExists("enable_multi_zones"); ok {
		request.EnableMultiZones = helper.Bool(v.(bool))
	}

	if userMultiZoneInfosMap, ok := helper.InterfacesHeadMap(d, "user_multi_zone_infos"); ok {
		networkInfo := cdwdorisv20211228.NetworkInfo{}
		if v, ok := userMultiZoneInfosMap["zone"]; ok {
			networkInfo.Zone = helper.String(v.(string))
		}
		if v, ok := userMultiZoneInfosMap["subnet_id"]; ok {
			networkInfo.SubnetId = helper.String(v.(string))
		}
		if v, ok := userMultiZoneInfosMap["subnet_ip_num"]; ok {
			networkInfo.SubnetIpNum = helper.IntInt64(v.(int))
		}
		request.UserMultiZoneInfos = &networkInfo
	}

	err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCdwdorisV20211228Client().CreateInstanceNewWithContext(ctx, request)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
		}
		response = result
		return nil
	})
	if err != nil {
		log.Printf("[CRITAL]%s create cdwdoris instance failed, reason:%+v", logId, err)
		return err
	}

	d.SetId(instanceId)

	return resourceTencentCloudCdwdorisInstanceRead(d, meta)
}

func resourceTencentCloudCdwdorisInstanceRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_cdwdoris_instance.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	service := CdwdorisService{client: meta.(tccommon.ProviderMeta).GetAPIV3Conn()}

	instanceId := d.Id()

	respData, err := service.DescribeCdwdorisInstanceById(ctx)
	if err != nil {
		return err
	}

	if respData == nil {
		d.SetId("")
		log.Printf("[WARN]%s resource `cdwdoris_instance` [%s] not found, please check if it has been deleted.\n", logId, d.Id())
		return nil
	}
	if respData.InstanceId != nil {
		_ = d.Set("instance_id", respData.InstanceId)
	}

	if respData.InstanceName != nil {
		_ = d.Set("instance_name", respData.InstanceName)
	}

	if respData.Status != nil {
		_ = d.Set("status", respData.Status)
	}

	if respData.Version != nil {
		_ = d.Set("version", respData.Version)
	}

	if respData.Region != nil {
		_ = d.Set("region", respData.Region)
	}

	if respData.Zone != nil {
		_ = d.Set("zone", respData.Zone)
	}

	if respData.VpcId != nil {
		_ = d.Set("vpc_id", respData.VpcId)
	}

	if respData.SubnetId != nil {
		_ = d.Set("subnet_id", respData.SubnetId)
	}

	if respData.PayMode != nil {
		_ = d.Set("pay_mode", respData.PayMode)
	}

	if respData.CreateTime != nil {
		_ = d.Set("create_time", respData.CreateTime)
	}

	if respData.ExpireTime != nil {
		_ = d.Set("expire_time", respData.ExpireTime)
	}

	masterSummaryMap := map[string]interface{}{}

	if respData.MasterSummary != nil {
		if respData.MasterSummary.Spec != nil {
			masterSummaryMap["spec"] = respData.MasterSummary.Spec
		}

		if respData.MasterSummary.NodeSize != nil {
			masterSummaryMap["node_size"] = respData.MasterSummary.NodeSize
		}

		if respData.MasterSummary.Core != nil {
			masterSummaryMap["core"] = respData.MasterSummary.Core
		}

		if respData.MasterSummary.Memory != nil {
			masterSummaryMap["memory"] = respData.MasterSummary.Memory
		}

		if respData.MasterSummary.Disk != nil {
			masterSummaryMap["disk"] = respData.MasterSummary.Disk
		}

		if respData.MasterSummary.DiskType != nil {
			masterSummaryMap["disk_type"] = respData.MasterSummary.DiskType
		}

		if respData.MasterSummary.DiskDesc != nil {
			masterSummaryMap["disk_desc"] = respData.MasterSummary.DiskDesc
		}

		attachCBSSpecMap := map[string]interface{}{}

		if respData.MasterSummary.AttachCBSSpec != nil {
			if respData.MasterSummary.AttachCBSSpec.DiskType != nil {
				attachCBSSpecMap["disk_type"] = respData.MasterSummary.AttachCBSSpec.DiskType
			}

			if respData.MasterSummary.AttachCBSSpec.DiskSize != nil {
				attachCBSSpecMap["disk_size"] = respData.MasterSummary.AttachCBSSpec.DiskSize
			}

			if respData.MasterSummary.AttachCBSSpec.DiskCount != nil {
				attachCBSSpecMap["disk_count"] = respData.MasterSummary.AttachCBSSpec.DiskCount
			}

			if respData.MasterSummary.AttachCBSSpec.DiskDesc != nil {
				attachCBSSpecMap["disk_desc"] = respData.MasterSummary.AttachCBSSpec.DiskDesc
			}

			masterSummaryMap["attach_cbs_spec"] = []interface{}{attachCBSSpecMap}
		}

		if respData.MasterSummary.SubProductType != nil {
			masterSummaryMap["sub_product_type"] = respData.MasterSummary.SubProductType
		}

		if respData.MasterSummary.SpecCore != nil {
			masterSummaryMap["spec_core"] = respData.MasterSummary.SpecCore
		}

		if respData.MasterSummary.SpecMemory != nil {
			masterSummaryMap["spec_memory"] = respData.MasterSummary.SpecMemory
		}

		if respData.MasterSummary.DiskCount != nil {
			masterSummaryMap["disk_count"] = respData.MasterSummary.DiskCount
		}

		if respData.MasterSummary.Encrypt != nil {
			masterSummaryMap["encrypt"] = respData.MasterSummary.Encrypt
		}

		if respData.MasterSummary.MaxDiskSize != nil {
			masterSummaryMap["max_disk_size"] = respData.MasterSummary.MaxDiskSize
		}

		_ = d.Set("master_summary", []interface{}{masterSummaryMap})
	}

	coreSummaryMap := map[string]interface{}{}

	if respData.CoreSummary != nil {
		if respData.CoreSummary.Spec != nil {
			coreSummaryMap["spec"] = respData.CoreSummary.Spec
		}

		if respData.CoreSummary.NodeSize != nil {
			coreSummaryMap["node_size"] = respData.CoreSummary.NodeSize
		}

		if respData.CoreSummary.Core != nil {
			coreSummaryMap["core"] = respData.CoreSummary.Core
		}

		if respData.CoreSummary.Memory != nil {
			coreSummaryMap["memory"] = respData.CoreSummary.Memory
		}

		if respData.CoreSummary.Disk != nil {
			coreSummaryMap["disk"] = respData.CoreSummary.Disk
		}

		if respData.CoreSummary.DiskType != nil {
			coreSummaryMap["disk_type"] = respData.CoreSummary.DiskType
		}

		if respData.CoreSummary.DiskDesc != nil {
			coreSummaryMap["disk_desc"] = respData.CoreSummary.DiskDesc
		}

		attachCBSSpecMap := map[string]interface{}{}

		if respData.CoreSummary.AttachCBSSpec != nil {
			if respData.CoreSummary.AttachCBSSpec.DiskType != nil {
				attachCBSSpecMap["disk_type"] = respData.CoreSummary.AttachCBSSpec.DiskType
			}

			if respData.CoreSummary.AttachCBSSpec.DiskSize != nil {
				attachCBSSpecMap["disk_size"] = respData.CoreSummary.AttachCBSSpec.DiskSize
			}

			if respData.CoreSummary.AttachCBSSpec.DiskCount != nil {
				attachCBSSpecMap["disk_count"] = respData.CoreSummary.AttachCBSSpec.DiskCount
			}

			if respData.CoreSummary.AttachCBSSpec.DiskDesc != nil {
				attachCBSSpecMap["disk_desc"] = respData.CoreSummary.AttachCBSSpec.DiskDesc
			}

			coreSummaryMap["attach_cbs_spec"] = []interface{}{attachCBSSpecMap}
		}

		if respData.CoreSummary.SubProductType != nil {
			coreSummaryMap["sub_product_type"] = respData.CoreSummary.SubProductType
		}

		if respData.CoreSummary.SpecCore != nil {
			coreSummaryMap["spec_core"] = respData.CoreSummary.SpecCore
		}

		if respData.CoreSummary.SpecMemory != nil {
			coreSummaryMap["spec_memory"] = respData.CoreSummary.SpecMemory
		}

		if respData.CoreSummary.DiskCount != nil {
			coreSummaryMap["disk_count"] = respData.CoreSummary.DiskCount
		}

		if respData.CoreSummary.Encrypt != nil {
			coreSummaryMap["encrypt"] = respData.CoreSummary.Encrypt
		}

		if respData.CoreSummary.MaxDiskSize != nil {
			coreSummaryMap["max_disk_size"] = respData.CoreSummary.MaxDiskSize
		}

		_ = d.Set("core_summary", []interface{}{coreSummaryMap})
	}

	if respData.HA != nil {
		_ = d.Set("ha", respData.HA)
	}

	if respData.HaType != nil {
		_ = d.Set("ha_type", respData.HaType)
	}

	if respData.AccessInfo != nil {
		_ = d.Set("access_info", respData.AccessInfo)
	}

	if respData.Id != nil {
		_ = d.Set("id", respData.Id)
	}

	if respData.RegionId != nil {
		_ = d.Set("region_id", respData.RegionId)
	}

	if respData.ZoneDesc != nil {
		_ = d.Set("zone_desc", respData.ZoneDesc)
	}

	if respData.FlowMsg != nil {
		_ = d.Set("flow_msg", respData.FlowMsg)
	}

	if respData.StatusDesc != nil {
		_ = d.Set("status_desc", respData.StatusDesc)
	}

	if respData.RenewFlag != nil {
		_ = d.Set("renew_flag", respData.RenewFlag)
	}

	tagsList := make([]map[string]interface{}, 0, len(respData.Tags))
	if respData.Tags != nil {
		for _, tags := range respData.Tags {
			tagsMap := map[string]interface{}{}

			if tags.TagKey != nil {
				tagsMap["tag_key"] = tags.TagKey
			}

			if tags.TagValue != nil {
				tagsMap["tag_value"] = tags.TagValue
			}

			tagsList = append(tagsList, tagsMap)
		}

		_ = d.Set("tags", tagsList)
	}

	if respData.Monitor != nil {
		_ = d.Set("monitor", respData.Monitor)
	}

	if respData.HasClsTopic != nil {
		_ = d.Set("has_cls_topic", respData.HasClsTopic)
	}

	if respData.ClsTopicId != nil {
		_ = d.Set("cls_topic_id", respData.ClsTopicId)
	}

	if respData.ClsLogSetId != nil {
		_ = d.Set("cls_log_set_id", respData.ClsLogSetId)
	}

	if respData.EnableXMLConfig != nil {
		_ = d.Set("enable_xml_config", respData.EnableXMLConfig)
	}

	if respData.RegionDesc != nil {
		_ = d.Set("region_desc", respData.RegionDesc)
	}

	if respData.Eip != nil {
		_ = d.Set("eip", respData.Eip)
	}

	if respData.CosMoveFactor != nil {
		_ = d.Set("cos_move_factor", respData.CosMoveFactor)
	}

	if respData.Kind != nil {
		_ = d.Set("kind", respData.Kind)
	}

	if respData.CosBucketName != nil {
		_ = d.Set("cos_bucket_name", respData.CosBucketName)
	}

	if respData.CanAttachCbs != nil {
		_ = d.Set("can_attach_cbs", respData.CanAttachCbs)
	}

	if respData.BuildVersion != nil {
		_ = d.Set("build_version", respData.BuildVersion)
	}

	if respData.Components != nil {
		_ = d.Set("components", respData.Components)
	}

	if respData.Characteristic != nil {
		_ = d.Set("characteristic", respData.Characteristic)
	}

	if respData.RestartTimeout != nil {
		_ = d.Set("restart_timeout", respData.RestartTimeout)
	}

	if respData.GraceShutdownWaitSeconds != nil {
		_ = d.Set("grace_shutdown_wait_seconds", respData.GraceShutdownWaitSeconds)
	}

	if respData.CaseSensitive != nil {
		_ = d.Set("case_sensitive", respData.CaseSensitive)
	}

	if respData.IsWhiteSGs != nil {
		_ = d.Set("is_white_s_gs", respData.IsWhiteSGs)
	}

	if respData.BindSGs != nil {
		_ = d.Set("bind_s_gs", respData.BindSGs)
	}

	if respData.EnableMultiZones != nil {
		_ = d.Set("enable_multi_zones", respData.EnableMultiZones)
	}

	if respData.UserNetworkInfos != nil {
		_ = d.Set("user_network_infos", respData.UserNetworkInfos)
	}

	if respData.EnableCoolDown != nil {
		_ = d.Set("enable_cool_down", respData.EnableCoolDown)
	}

	if respData.CoolDownBucket != nil {
		_ = d.Set("cool_down_bucket", respData.CoolDownBucket)
	}

	respData1, err := service.DescribeCdwdorisInstanceById1(ctx)
	if err != nil {
		return err
	}

	if respData1 == nil {
		d.SetId("")
		log.Printf("[WARN]%s resource `cdwdoris_instance` [%s] not found, please check if it has been deleted.\n", logId, d.Id())
		return nil
	}
	if respData1.InstanceState != nil {
		_ = d.Set("instance_state", respData1.InstanceState)
	}

	if respData1.FlowCreateTime != nil {
		_ = d.Set("flow_create_time", respData1.FlowCreateTime)
	}

	if respData1.FlowName != nil {
		_ = d.Set("flow_name", respData1.FlowName)
	}

	if respData1.FlowProgress != nil {
		_ = d.Set("flow_progress", respData1.FlowProgress)
	}

	if respData1.InstanceStateDesc != nil {
		_ = d.Set("instance_state_desc", respData1.InstanceStateDesc)
	}

	if respData1.FlowMsg != nil {
		_ = d.Set("flow_msg", respData1.FlowMsg)
	}

	respData2, err := service.DescribeCdwdorisInstanceById2(ctx)
	if err != nil {
		return err
	}

	if respData2 == nil {
		d.SetId("")
		log.Printf("[WARN]%s resource `cdwdoris_instance` [%s] not found, please check if it has been deleted.\n", logId, d.Id())
		return nil
	}
	operationsList := make([]map[string]interface{}, 0, len(respData2.Operations))
	if respData2.Operations != nil {
		for _, operations := range respData2.Operations {
			operationsMap := map[string]interface{}{}

			if operations.Name != nil {
				operationsMap["name"] = operations.Name
			}

			if operations.Result != nil {
				operationsMap["result"] = operations.Result
			}

			if operations.Desc != nil {
				operationsMap["desc"] = operations.Desc
			}

			if operations.Level != nil {
				operationsMap["level"] = operations.Level
			}

			if operations.LevelDesc != nil {
				operationsMap["level_desc"] = operations.LevelDesc
			}

			if operations.StartTime != nil {
				operationsMap["start_time"] = operations.StartTime
			}

			if operations.EndTime != nil {
				operationsMap["end_time"] = operations.EndTime
			}

			if operations.ResultDesc != nil {
				operationsMap["result_desc"] = operations.ResultDesc
			}

			if operations.OperateUin != nil {
				operationsMap["operate_uin"] = operations.OperateUin
			}

			if operations.JobId != nil {
				operationsMap["job_id"] = operations.JobId
			}

			if operations.OperationDetail != nil {
				operationsMap["operation_detail"] = operations.OperationDetail
			}

			operationsList = append(operationsList, operationsMap)
		}

		_ = d.Set("operations", operationsList)
	}

	_ = instanceId
	return nil
}

func resourceTencentCloudCdwdorisInstanceUpdate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_cdwdoris_instance.update")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	immutableArgs := []string{"zone", "fe_spec", "be_spec", "ha_flag", "user_vpc_id", "user_subnet_id", "product_version", "charge_properties", "doris_user_pwd", "tags", "case_sensitive", "enable_multi_zones", "user_multi_zone_infos"}
	for _, v := range immutableArgs {
		if d.HasChange(v) {
			return fmt.Errorf("argument `%s` cannot be changed", v)
		}
	}
	instanceId := d.Id()

	needChange := false
	mutableArgs := []string{"instance_id", "instance_name"}
	for _, v := range mutableArgs {
		if d.HasChange(v) {
			needChange = true
			break
		}
	}

	if needChange {
		request := cdwdorisv20211228.NewModifyInstanceRequest()

		if v, ok := d.GetOk("instance_id"); ok {
			request.InstanceId = helper.String(v.(string))
		}

		if v, ok := d.GetOk("instance_name"); ok {
			request.InstanceName = helper.String(v.(string))
		}

		err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCdwdorisV20211228Client().ModifyInstanceWithContext(ctx, request)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
			}
			return nil
		})
		if err != nil {
			log.Printf("[CRITAL]%s update cdwdoris instance failed, reason:%+v", logId, err)
			return err
		}
	}

	needChange1 := false
	mutableArgs1 := []string{"instance_id", "type", "node_count", "ha_type"}
	for _, v := range mutableArgs1 {
		if d.HasChange(v) {
			needChange1 = true
			break
		}
	}

	if needChange1 {
		request1 := cdwdorisv20211228.NewScaleOutInstanceRequest()

		if v, ok := d.GetOk("instance_id"); ok {
			request1.InstanceId = helper.String(v.(string))
		}

		if v, ok := d.GetOk("type"); ok {
			request1.Type = helper.String(v.(string))
		}

		if v, ok := d.GetOkExists("node_count"); ok {
			request1.NodeCount = helper.IntUint64(v.(int))
		}

		if v, ok := d.GetOkExists("ha_type"); ok {
			request1.HaType = helper.IntInt64(v.(int))
		}

		err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCdwdorisV20211228Client().ScaleOutInstanceWithContext(ctx, request1)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request1.GetAction(), request1.ToJsonString(), result.ToJsonString())
			}
			return nil
		})
		if err != nil {
			log.Printf("[CRITAL]%s update cdwdoris instance failed, reason:%+v", logId, err)
			return err
		}
	}

	needChange2 := false
	mutableArgs2 := []string{"instance_id", "spec_name", "type"}
	for _, v := range mutableArgs2 {
		if d.HasChange(v) {
			needChange2 = true
			break
		}
	}

	if needChange2 {
		request2 := cdwdorisv20211228.NewScaleUpInstanceRequest()

		if v, ok := d.GetOk("instance_id"); ok {
			request2.InstanceId = helper.String(v.(string))
		}

		if v, ok := d.GetOk("spec_name"); ok {
			request2.SpecName = helper.String(v.(string))
		}

		if v, ok := d.GetOk("type"); ok {
			request2.Type = helper.String(v.(string))
		}

		err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCdwdorisV20211228Client().ScaleUpInstanceWithContext(ctx, request2)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request2.GetAction(), request2.ToJsonString(), result.ToJsonString())
			}
			return nil
		})
		if err != nil {
			log.Printf("[CRITAL]%s update cdwdoris instance failed, reason:%+v", logId, err)
			return err
		}
	}

	needChange3 := false
	mutableArgs3 := []string{"instance_id", "del_hosts", "type", "ha_type"}
	for _, v := range mutableArgs3 {
		if d.HasChange(v) {
			needChange3 = true
			break
		}
	}

	if needChange3 {
		request3 := cdwdorisv20211228.NewReduceInstanceRequest()

		if v, ok := d.GetOk("instance_id"); ok {
			request3.InstanceId = helper.String(v.(string))
		}

		if v, ok := d.GetOk("del_hosts"); ok {
			delHostsSet := v.([]interface{})
			for i := range delHostsSet {
				delHosts := delHostsSet[i].(string)
				request3.DelHosts = append(request3.DelHosts, helper.String(delHosts))
			}
		}

		if v, ok := d.GetOk("type"); ok {
			request3.Type = helper.String(v.(string))
		}

		if v, ok := d.GetOkExists("ha_type"); ok {
			request3.HaType = helper.IntInt64(v.(int))
		}

		err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCdwdorisV20211228Client().ReduceInstanceWithContext(ctx, request3)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request3.GetAction(), request3.ToJsonString(), result.ToJsonString())
			}
			return nil
		})
		if err != nil {
			log.Printf("[CRITAL]%s update cdwdoris instance failed, reason:%+v", logId, err)
			return err
		}
	}

	needChange4 := false
	mutableArgs4 := []string{"instance_id", "type", "disk_size"}
	for _, v := range mutableArgs4 {
		if d.HasChange(v) {
			needChange4 = true
			break
		}
	}

	if needChange4 {
		request4 := cdwdorisv20211228.NewResizeDiskRequest()

		if v, ok := d.GetOk("instance_id"); ok {
			request4.InstanceId = helper.String(v.(string))
		}

		if v, ok := d.GetOk("type"); ok {
			request4.Type = helper.String(v.(string))
		}

		if v, ok := d.GetOkExists("disk_size"); ok {
			request4.DiskSize = helper.IntUint64(v.(int))
		}

		err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCdwdorisV20211228Client().ResizeDiskWithContext(ctx, request4)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request4.GetAction(), request4.ToJsonString(), result.ToJsonString())
			}
			return nil
		})
		if err != nil {
			log.Printf("[CRITAL]%s update cdwdoris instance failed, reason:%+v", logId, err)
			return err
		}
	}

	_ = instanceId
	return resourceTencentCloudCdwdorisInstanceRead(d, meta)
}

func resourceTencentCloudCdwdorisInstanceDelete(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_cdwdoris_instance.delete")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)
	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	instanceId := d.Id()

	var (
		request  = cdwdorisv20211228.NewDestroyInstanceRequest()
		response = cdwdorisv20211228.NewDestroyInstanceResponse()
	)

	if v, ok := d.GetOk("instance_id"); ok {
		request.InstanceId = helper.String(v.(string))
	}

	err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCdwdorisV20211228Client().DestroyInstanceWithContext(ctx, request)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
		}
		response = result
		return nil
	})
	if err != nil {
		log.Printf("[CRITAL]%s delete cdwdoris instance failed, reason:%+v", logId, err)
		return err
	}

	_ = instanceId
	return nil
}
