// Code generated by iacg; DO NOT EDIT.
package cvm

import (
	"context"
	"log"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	cvm "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/cvm/v20170312"

	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
)

func ResourceTencentCloudCvmLaunchTemplate() *schema.Resource {
	return &schema.Resource{
		Create: resourceTencentCloudCvmLaunchTemplateCreate,
		Read:   resourceTencentCloudCvmLaunchTemplateRead,
		Delete: resourceTencentCloudCvmLaunchTemplateDelete,
		Schema: map[string]*schema.Schema{
			"launch_template_name": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: "The name of launch template.",
			},

			"placement": {
				Type:        schema.TypeList,
				Required:    true,
				ForceNew:    true,
				MaxItems:    1,
				Description: "The location of instance.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"zone": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The available zone ID of the instance.",
						},
						"project_id": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The project ID of the instance.",
						},
						"host_ids": {
							Type:        schema.TypeSet,
							Elem:        &schema.Schema{Type: schema.TypeString},
							Optional:    true,
							Description: "The CDH ID list of the instance(input).",
						},
						"host_ips": {
							Type:        schema.TypeSet,
							Elem:        &schema.Schema{Type: schema.TypeString},
							Optional:    true,
							Deprecated:  "It has been deprecated from version 1.81.108.",
							Description: "Specify the host machine ip.",
						},
					},
				},
			},

			"image_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: "Image ID.",
			},

			"launch_template_version_description": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: "Instance launch template version description.",
			},

			"instance_type": {
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
				ForceNew:    true,
				Description: "The type of the instance. If this parameter is not specified, the system will dynamically specify the default model according to the resource sales in the current region.",
			},

			"system_disk": {
				Type:        schema.TypeList,
				Optional:    true,
				Computed:    true,
				ForceNew:    true,
				MaxItems:    1,
				Description: "System disk configuration information of the instance. If this parameter is not specified, it is assigned according to the system default.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"disk_type": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The type of system disk.",
						},
						"disk_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "System disk ID.",
						},
						"disk_size": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The size of system disk.",
						},
						"cdc_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Cloud Dedicated Cluster(CDC) ID.",
						},
					},
				},
			},

			"data_disks": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				Description: "Data disk configuration information of the instance.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"disk_size": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "The size of the data disk.",
						},
						"disk_type": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The type of data disk.",
						},
						"disk_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Data disk ID.",
						},
						"delete_with_instance": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Whether the data disk is destroyed along with the instance, true or false.",
						},
						"snapshot_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Data disk snapshot ID.",
						},
						"encrypt": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Whether the data disk is encrypted, TRUE or FALSE.",
						},
						"kms_key_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The id of custom CMK.",
						},
						"throughput_performance": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "Cloud disk performance, MB/s.",
						},
						"cdc_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Cloud Dedicated Cluster(CDC) ID.",
						},
					},
				},
			},

			"virtual_private_cloud": {
				Type:        schema.TypeList,
				Optional:    true,
				Computed:    true,
				ForceNew:    true,
				MaxItems:    1,
				Description: "The configuration information of VPC. If this parameter is not specified, the basic network is used by default.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"vpc_id": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The id of VPC.",
						},
						"subnet_id": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The id of subnet.",
						},
						"as_vpc_gateway": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Is it used as a Public network gateway, TRUE or FALSE.",
						},
						"private_ip_addresses": {
							Type:        schema.TypeSet,
							Optional:    true,
							Description: "The address of private ip.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"ipv6_address_count": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The number of ipv6 addresses for Elastic Network Interface.",
						},
					},
				},
			},

			"internet_accessible": {
				Type:        schema.TypeList,
				Optional:    true,
				Computed:    true,
				ForceNew:    true,
				MaxItems:    1,
				Description: "The information settings of public network bandwidth. If you do not specify this parameter, the default Internet bandwidth is 0 Mbps.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"internet_charge_type": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The type of internet charge.",
						},
						"internet_max_bandwidth_out": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "Internet outbound bandwidth upper limit, Mbps.",
						},
						"public_ip_assigned": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Whether to allocate public network IP, TRUE or FALSE.",
						},
						"bandwidth_package_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The ID of bandwidth package.",
						},
					},
				},
			},

			"instance_count": {
				Type:        schema.TypeInt,
				Optional:    true,
				ForceNew:    true,
				Default:     1,
				Description: "The number of instances purchased.",
			},

			"instance_name": {
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
				ForceNew:    true,
				Description: "The name of instance. If you do not specify an instance display name, 'Unnamed' is displayed by default.",
			},

			"login_settings": {
				Type:        schema.TypeList,
				Optional:    true,
				Computed:    true,
				ForceNew:    true,
				MaxItems:    1,
				Description: "The login settings of instance. By default, passwords are randomly generated and notified to users via internal messages.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The login password of instance.",
						},
						"key_ids": {
							Type:        schema.TypeSet,
							Optional:    true,
							Description: "List of key ID.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"keep_image_login": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Keep the original settings of the mirror.",
						},
					},
				},
			},

			"security_group_ids": {
				Type:        schema.TypeSet,
				Optional:    true,
				Computed:    true,
				ForceNew:    true,
				Description: "The security group ID of instance. If this parameter is not specified, the default security group is bound.",
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},

			"enhanced_service": {
				Type:        schema.TypeList,
				Optional:    true,
				Computed:    true,
				ForceNew:    true,
				MaxItems:    1,
				Description: "Enhanced service. If this parameter is not specified, cloud monitoring and cloud security services will be enabled by default in public images.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"security_service": {
							Type:        schema.TypeList,
							Optional:    true,
							MaxItems:    1,
							Description: "Enable cloud security service.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"enabled": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "Whether to enable cloud security service, TRUE or FALSE.",
									},
								},
							},
						},
						"monitor_service": {
							Type:        schema.TypeList,
							Optional:    true,
							MaxItems:    1,
							Description: "Enable cloud monitor service.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"enabled": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "Whether to enable cloud monitor service, TRUE or FALSE.",
									},
								},
							},
						},
						"automation_service": {
							Type:        schema.TypeList,
							Optional:    true,
							MaxItems:    1,
							Description: "Enable TencentCloud Automation Tools(TAT).",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"enabled": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "Whether to enable TencentCloud Automation Tools(TAT), TRUE or FALSE.",
									},
								},
							},
						},
					},
				},
			},

			"client_token": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: "A string to used guarantee request idempotency.",
			},

			"host_name": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: "The host name of CVM.",
			},

			"action_timer": {
				Type:        schema.TypeList,
				Optional:    true,
				Computed:    true,
				ForceNew:    true,
				MaxItems:    1,
				Description: "Timed task.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"timer_action": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Timer name.",
						},
						"action_time": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Execution time.",
						},
						"externals": {
							Type:        schema.TypeList,
							Optional:    true,
							MaxItems:    1,
							Description: "Extended data.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"release_address": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "Release address.",
									},
									"unsupport_networks": {
										Type:        schema.TypeSet,
										Optional:    true,
										Description: "Unsupported network type.",
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"storage_block_attr": {
										Type:        schema.TypeList,
										Optional:    true,
										MaxItems:    1,
										Description: "HDD local storage attributes.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"type": {
													Type:        schema.TypeString,
													Required:    true,
													Description: "The type of HDD local storage.",
												},
												"min_size": {
													Type:        schema.TypeInt,
													Required:    true,
													Description: "The minimum capacity of HDD local storage.",
												},
												"max_size": {
													Type:        schema.TypeInt,
													Required:    true,
													Description: "The maximum capacity of HDD local storage.",
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},

			"disaster_recover_group_ids": {
				Type:        schema.TypeSet,
				Optional:    true,
				ForceNew:    true,
				Description: "The ID of disaster recover group.",
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},

			"tag_specification": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				Description: "Tag description list.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"resource_type": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The type of resource.",
						},
						"tags": {
							Type:        schema.TypeList,
							Required:    true,
							Description: "Tag list.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"key": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "The key of tag.",
									},
									"value": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "The value of tag.",
									},
								},
							},
						},
					},
				},
			},

			"instance_market_options": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				MaxItems:    1,
				Description: "The marketplace options of instance.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"spot_options": {
							Type:        schema.TypeList,
							Required:    true,
							MaxItems:    1,
							Description: "Bidding related options.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"max_price": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Bidding.",
									},
									"spot_instance_type": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Bidding request type, currently only supported type: one-time.",
									},
								},
							},
						},
						"market_type": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Market option type, currently only supports value: spot.",
						},
					},
				},
			},

			"user_data": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: "The data of users.",
			},

			"dry_run": {
				Type:        schema.TypeBool,
				Optional:    true,
				ForceNew:    true,
				Description: "Whether to preflight only this request, true or false.",
			},

			"cam_role_name": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: "The role name of CAM.",
			},

			"hpc_cluster_id": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: "The ID of HPC cluster.",
			},

			"instance_charge_type": {
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
				ForceNew:    true,
				Description: "The charge type of instance. Default value: POSTPAID_BY_HOUR.",
			},

			"instance_charge_prepaid": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				MaxItems:    1,
				Description: "The configuration of charge prepaid.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"period": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "The period of purchasing instances.",
						},
						"renew_flag": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Automatic renew flag.",
						},
					},
				},
			},

			"disable_api_termination": {
				Type:        schema.TypeBool,
				Optional:    true,
				ForceNew:    true,
				Description: "Instance destruction protection flag.",
			},

			"tags": {
				Type:        schema.TypeMap,
				Optional:    true,
				ForceNew:    true,
				Description: "Tag description list.",
			},
		},
	}
}

func resourceTencentCloudCvmLaunchTemplateCreate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_cvm_launch_template.create")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	var (
		launchTemplateId string
	)
	var (
		request  = cvm.NewCreateLaunchTemplateRequest()
		response = cvm.NewCreateLaunchTemplateResponse()
	)

	if v, ok := d.GetOk("launch_template_name"); ok {
		request.LaunchTemplateName = helper.String(v.(string))
	}

	if placementMap, ok := helper.InterfacesHeadMap(d, "placement"); ok {
		placement := cvm.Placement{}
		if v, ok := placementMap["zone"]; ok {
			placement.Zone = helper.String(v.(string))
		}
		if v, ok := placementMap["project_id"]; ok {
			placement.ProjectId = helper.IntInt64(v.(int))
		}
		if v, ok := placementMap["host_ids"]; ok {
			hostIdsSet := v.(*schema.Set).List()
			for i := range hostIdsSet {
				hostIds := hostIdsSet[i].(string)
				placement.HostIds = append(placement.HostIds, helper.String(hostIds))
			}
		}
		// It has been deprecated from version 1.81.108
		//if v, ok := dMap["host_ips"]; ok {
		//	hostIpsSet := v.(*schema.Set).List()
		//	for i := range hostIpsSet {
		//		hostIps := hostIpsSet[i].(string)
		//		placement.HostIps = append(placement.HostIps, &hostIps)
		//	}
		//}
		if v, ok := placementMap["host_id"]; ok {
			placement.HostId = helper.String(v.(string))
		}
		request.Placement = &placement
	}

	if v, ok := d.GetOk("image_id"); ok {
		request.ImageId = helper.String(v.(string))
	}

	if v, ok := d.GetOk("launch_template_version_description"); ok {
		request.LaunchTemplateVersionDescription = helper.String(v.(string))
	}

	if v, ok := d.GetOk("instance_type"); ok {
		request.InstanceType = helper.String(v.(string))
	}

	if systemDiskMap, ok := helper.InterfacesHeadMap(d, "system_disk"); ok {
		systemDisk := cvm.SystemDisk{}
		if v, ok := systemDiskMap["disk_type"]; ok {
			systemDisk.DiskType = helper.String(v.(string))
		}
		if v, ok := systemDiskMap["disk_id"]; ok {
			systemDisk.DiskId = helper.String(v.(string))
		}
		if v, ok := systemDiskMap["disk_size"]; ok {
			systemDisk.DiskSize = helper.IntInt64(v.(int))
		}
		if v, ok := systemDiskMap["cdc_id"]; ok {
			systemDisk.CdcId = helper.String(v.(string))
		}
		request.SystemDisk = &systemDisk
	}

	if v, ok := d.GetOk("data_disks"); ok {
		for _, item := range v.([]interface{}) {
			dataDisksMap := item.(map[string]interface{})
			dataDisk := cvm.DataDisk{}
			if v, ok := dataDisksMap["disk_size"]; ok {
				dataDisk.DiskSize = helper.IntInt64(v.(int))
			}
			if v, ok := dataDisksMap["disk_type"]; ok {
				dataDisk.DiskType = helper.String(v.(string))
			}
			if v, ok := dataDisksMap["disk_id"]; ok {
				dataDisk.DiskId = helper.String(v.(string))
			}
			if v, ok := dataDisksMap["delete_with_instance"]; ok {
				dataDisk.DeleteWithInstance = helper.Bool(v.(bool))
			}
			if v, ok := dataDisksMap["snapshot_id"]; ok {
				dataDisk.SnapshotId = helper.String(v.(string))
			}
			if v, ok := dataDisksMap["encrypt"]; ok {
				dataDisk.Encrypt = helper.Bool(v.(bool))
			}
			if v, ok := dataDisksMap["kms_key_id"]; ok {
				dataDisk.KmsKeyId = helper.String(v.(string))
			}
			if v, ok := dataDisksMap["throughput_performance"]; ok {
				dataDisk.ThroughputPerformance = helper.IntInt64(v.(int))
			}
			if v, ok := dataDisksMap["cdc_id"]; ok {
				dataDisk.CdcId = helper.String(v.(string))
			}
			request.DataDisks = append(request.DataDisks, &dataDisk)
		}
	}

	if virtualPrivateCloudMap, ok := helper.InterfacesHeadMap(d, "virtual_private_cloud"); ok {
		virtualPrivateCloud := cvm.VirtualPrivateCloud{}
		if v, ok := virtualPrivateCloudMap["vpc_id"]; ok {
			virtualPrivateCloud.VpcId = helper.String(v.(string))
		}
		if v, ok := virtualPrivateCloudMap["subnet_id"]; ok {
			virtualPrivateCloud.SubnetId = helper.String(v.(string))
		}
		if v, ok := virtualPrivateCloudMap["as_vpc_gateway"]; ok {
			virtualPrivateCloud.AsVpcGateway = helper.Bool(v.(bool))
		}
		if v, ok := virtualPrivateCloudMap["private_ip_addresses"]; ok {
			privateIpAddressesSet := v.(*schema.Set).List()
			for i := range privateIpAddressesSet {
				privateIpAddresses := privateIpAddressesSet[i].(string)
				virtualPrivateCloud.PrivateIpAddresses = append(virtualPrivateCloud.PrivateIpAddresses, helper.String(privateIpAddresses))
			}
		}
		if v, ok := virtualPrivateCloudMap["ipv6_address_count"]; ok {
			virtualPrivateCloud.Ipv6AddressCount = helper.IntUint64(v.(int))
		}
		request.VirtualPrivateCloud = &virtualPrivateCloud
	}

	if internetAccessibleMap, ok := helper.InterfacesHeadMap(d, "internet_accessible"); ok {
		internetAccessible := cvm.InternetAccessible{}
		if v, ok := internetAccessibleMap["internet_charge_type"]; ok {
			internetAccessible.InternetChargeType = helper.String(v.(string))
		}
		if v, ok := internetAccessibleMap["internet_max_bandwidth_out"]; ok {
			internetAccessible.InternetMaxBandwidthOut = helper.IntInt64(v.(int))
		}
		if v, ok := internetAccessibleMap["public_ip_assigned"]; ok {
			internetAccessible.PublicIpAssigned = helper.Bool(v.(bool))
		}
		if v, ok := internetAccessibleMap["bandwidth_package_id"]; ok {
			internetAccessible.BandwidthPackageId = helper.String(v.(string))
		}
		request.InternetAccessible = &internetAccessible
	}

	if v, ok := d.GetOkExists("instance_count"); ok {
		request.InstanceCount = helper.IntInt64(v.(int))
	}

	if v, ok := d.GetOk("instance_name"); ok {
		request.InstanceName = helper.String(v.(string))
	}

	if loginSettingsMap, ok := helper.InterfacesHeadMap(d, "login_settings"); ok {
		loginSettings := cvm.LoginSettings{}
		if v, ok := loginSettingsMap["password"]; ok {
			loginSettings.Password = helper.String(v.(string))
		}
		if v, ok := loginSettingsMap["key_ids"]; ok {
			keyIdsSet := v.(*schema.Set).List()
			for i := range keyIdsSet {
				keyIds := keyIdsSet[i].(string)
				loginSettings.KeyIds = append(loginSettings.KeyIds, helper.String(keyIds))
			}
		}
		if v, ok := loginSettingsMap["keep_image_login"]; ok {
			loginSettings.KeepImageLogin = helper.String(v.(string))
		}
		request.LoginSettings = &loginSettings
	}

	if v, ok := d.GetOk("security_group_ids"); ok {
		securityGroupIdsSet := v.(*schema.Set).List()
		for i := range securityGroupIdsSet {
			securityGroupIds := securityGroupIdsSet[i].(string)
			request.SecurityGroupIds = append(request.SecurityGroupIds, helper.String(securityGroupIds))
		}
	}

	if enhancedServiceMap, ok := helper.InterfacesHeadMap(d, "enhanced_service"); ok {
		enhancedService := cvm.EnhancedService{}
		if securityServiceMap, ok := helper.ConvertInterfacesHeadToMap(enhancedServiceMap["security_service"]); ok {
			runSecurityServiceEnabled := cvm.RunSecurityServiceEnabled{}
			if v, ok := securityServiceMap["enabled"]; ok {
				runSecurityServiceEnabled.Enabled = helper.Bool(v.(bool))
			}
			enhancedService.SecurityService = &runSecurityServiceEnabled
		}
		if monitorServiceMap, ok := helper.ConvertInterfacesHeadToMap(enhancedServiceMap["monitor_service"]); ok {
			runMonitorServiceEnabled := cvm.RunMonitorServiceEnabled{}
			if v, ok := monitorServiceMap["enabled"]; ok {
				runMonitorServiceEnabled.Enabled = helper.Bool(v.(bool))
			}
			enhancedService.MonitorService = &runMonitorServiceEnabled
		}
		if automationServiceMap, ok := helper.ConvertInterfacesHeadToMap(enhancedServiceMap["automation_service"]); ok {
			runAutomationServiceEnabled := cvm.RunAutomationServiceEnabled{}
			if v, ok := automationServiceMap["enabled"]; ok {
				runAutomationServiceEnabled.Enabled = helper.Bool(v.(bool))
			}
			enhancedService.AutomationService = &runAutomationServiceEnabled
		}
		request.EnhancedService = &enhancedService
	}

	if v, ok := d.GetOk("client_token"); ok {
		request.ClientToken = helper.String(v.(string))
	}

	if v, ok := d.GetOk("host_name"); ok {
		request.HostName = helper.String(v.(string))
	}

	if actionTimerMap, ok := helper.InterfacesHeadMap(d, "action_timer"); ok {
		actionTimer := cvm.ActionTimer{}
		if v, ok := actionTimerMap["timer_action"]; ok {
			actionTimer.TimerAction = helper.String(v.(string))
		}
		if v, ok := actionTimerMap["action_time"]; ok {
			actionTimer.ActionTime = helper.String(v.(string))
		}
		if externalsMap, ok := helper.ConvertInterfacesHeadToMap(actionTimerMap["externals"]); ok {
			externals := cvm.Externals{}
			if v, ok := externalsMap["release_address"]; ok {
				externals.ReleaseAddress = helper.Bool(v.(bool))
			}
			if v, ok := externalsMap["unsupport_networks"]; ok {
				unsupportNetworksSet := v.(*schema.Set).List()
				for i := range unsupportNetworksSet {
					unsupportNetworks := unsupportNetworksSet[i].(string)
					externals.UnsupportNetworks = append(externals.UnsupportNetworks, helper.String(unsupportNetworks))
				}
			}
			if storageBlockAttrMap, ok := helper.ConvertInterfacesHeadToMap(externalsMap["storage_block_attr"]); ok {
				storageBlock := cvm.StorageBlock{}
				if v, ok := storageBlockAttrMap["type"]; ok {
					storageBlock.Type = helper.String(v.(string))
				}
				if v, ok := storageBlockAttrMap["min_size"]; ok {
					storageBlock.MinSize = helper.IntInt64(v.(int))
				}
				if v, ok := storageBlockAttrMap["max_size"]; ok {
					storageBlock.MaxSize = helper.IntInt64(v.(int))
				}
				externals.StorageBlockAttr = &storageBlock
			}
			actionTimer.Externals = &externals
		}
		request.ActionTimer = &actionTimer
	}

	if v, ok := d.GetOk("disaster_recover_group_ids"); ok {
		disasterRecoverGroupIdsSet := v.(*schema.Set).List()
		for i := range disasterRecoverGroupIdsSet {
			disasterRecoverGroupIds := disasterRecoverGroupIdsSet[i].(string)
			request.DisasterRecoverGroupIds = append(request.DisasterRecoverGroupIds, helper.String(disasterRecoverGroupIds))
		}
	}

	if v, ok := d.GetOk("tag_specification"); ok {
		for _, item := range v.([]interface{}) {
			tagSpecificationMap := item.(map[string]interface{})
			tagSpecification := cvm.TagSpecification{}
			if v, ok := tagSpecificationMap["resource_type"]; ok {
				tagSpecification.ResourceType = helper.String(v.(string))
			}
			if v, ok := tagSpecificationMap["tags"]; ok {
				for _, item := range v.([]interface{}) {
					tagsMap := item.(map[string]interface{})
					tag := cvm.Tag{}
					if v, ok := tagsMap["key"]; ok {
						tag.Key = helper.String(v.(string))
					}
					if v, ok := tagsMap["value"]; ok {
						tag.Value = helper.String(v.(string))
					}
					tagSpecification.Tags = append(tagSpecification.Tags, &tag)
				}
			}
			request.TagSpecification = append(request.TagSpecification, &tagSpecification)
		}
	}

	if instanceMarketOptionsMap, ok := helper.InterfacesHeadMap(d, "instance_market_options"); ok {
		instanceMarketOptionsRequest := cvm.InstanceMarketOptionsRequest{}
		if spotOptionsMap, ok := helper.ConvertInterfacesHeadToMap(instanceMarketOptionsMap["spot_options"]); ok {
			spotMarketOptions := cvm.SpotMarketOptions{}
			if v, ok := spotOptionsMap["max_price"]; ok {
				spotMarketOptions.MaxPrice = helper.String(v.(string))
			}
			if v, ok := spotOptionsMap["spot_instance_type"]; ok {
				spotMarketOptions.SpotInstanceType = helper.String(v.(string))
			}
			instanceMarketOptionsRequest.SpotOptions = &spotMarketOptions
		}
		if v, ok := instanceMarketOptionsMap["market_type"]; ok {
			instanceMarketOptionsRequest.MarketType = helper.String(v.(string))
		}
		request.InstanceMarketOptions = &instanceMarketOptionsRequest
	}

	if v, ok := d.GetOk("user_data"); ok {
		request.UserData = helper.String(v.(string))
	}

	if v, ok := d.GetOkExists("dry_run"); ok {
		request.DryRun = helper.Bool(v.(bool))
	}

	if v, ok := d.GetOk("cam_role_name"); ok {
		request.CamRoleName = helper.String(v.(string))
	}

	if v, ok := d.GetOk("hpc_cluster_id"); ok {
		request.HpcClusterId = helper.String(v.(string))
	}

	if v, ok := d.GetOk("instance_charge_type"); ok {
		request.InstanceChargeType = helper.String(v.(string))
	}

	if instanceChargePrepaidMap, ok := helper.InterfacesHeadMap(d, "instance_charge_prepaid"); ok {
		instanceChargePrepaid := cvm.InstanceChargePrepaid{}
		if v, ok := instanceChargePrepaidMap["period"]; ok {
			instanceChargePrepaid.Period = helper.IntInt64(v.(int))
		}
		if v, ok := instanceChargePrepaidMap["renew_flag"]; ok {
			instanceChargePrepaid.RenewFlag = helper.String(v.(string))
		}
		request.InstanceChargePrepaid = &instanceChargePrepaid
	}

	if v, ok := d.GetOkExists("disable_api_termination"); ok {
		request.DisableApiTermination = helper.Bool(v.(bool))
	}

	err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCvmClient().CreateLaunchTemplateWithContext(ctx, request)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
		}
		response = result
		return nil
	})
	if err != nil {
		log.Printf("[CRITAL]%s create cvm launch template failed, reason:%+v", logId, err)
		return err
	}

	launchTemplateId = *response.Response.LaunchTemplateId

	d.SetId(launchTemplateId)

	return resourceTencentCloudCvmLaunchTemplateRead(d, meta)
}

func resourceTencentCloudCvmLaunchTemplateRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_cvm_launch_template.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	service := CvmService{client: meta.(tccommon.ProviderMeta).GetAPIV3Conn()}

	launchTemplateId := d.Id()

	respData, err := service.DescribeCvmLaunchTemplateById(ctx, launchTemplateId)
	if err != nil {
		return err
	}

	if respData == nil {
		d.SetId("")
		log.Printf("[WARN]%s resource `cvm_launch_template` [%s] not found, please check if it has been deleted.\n", logId, d.Id())
		return nil
	}
	if respData.LaunchTemplateName != nil {
		_ = d.Set("launch_template_name", respData.LaunchTemplateName)
	}

	respData1, err := service.DescribeCvmLaunchTemplateById1(ctx, launchTemplateId)
	if err != nil {
		return err
	}

	if respData1 == nil {
		d.SetId("")
		log.Printf("[WARN]%s resource `cvm_launch_template` [%s] not found, please check if it has been deleted.\n", logId, d.Id())
		return nil
	}
	if respData1.LaunchTemplateVersionData != nil {
		placementMap := map[string]interface{}{}

		if respData1.LaunchTemplateVersionData.Placement != nil {
			if respData1.LaunchTemplateVersionData.Placement.Zone != nil {
				placementMap["zone"] = respData1.LaunchTemplateVersionData.Placement.Zone
			}

			if respData1.LaunchTemplateVersionData.Placement.ProjectId != nil {
				placementMap["project_id"] = respData1.LaunchTemplateVersionData.Placement.ProjectId
			}

			if respData1.LaunchTemplateVersionData.Placement.HostIds != nil {
				placementMap["host_ids"] = respData1.LaunchTemplateVersionData.Placement.HostIds
			}

			if respData1.LaunchTemplateVersionData.Placement.HostId != nil {
				placementMap["host_id"] = respData1.LaunchTemplateVersionData.Placement.HostId
			}

			_ = d.Set("placement", []interface{}{placementMap})
		}

		if respData1.LaunchTemplateVersionData.InstanceType != nil {
			_ = d.Set("instance_type", respData1.LaunchTemplateVersionData.InstanceType)
		}

		// It has been deprecated from version 1.81.108
		//if launchTemplateVersion.LaunchTemplateVersionData.Placement.HostIps != nil {
		//	placementMap["host_ips"] = launchTemplateVersion.LaunchTemplateVersionData.Placement.HostIps
		//}

		if respData1.LaunchTemplateVersionData.InstanceChargeType != nil {
			_ = d.Set("instance_charge_type", respData1.LaunchTemplateVersionData.InstanceChargeType)
		}

		systemDiskMap := map[string]interface{}{}

		if respData1.LaunchTemplateVersionData.SystemDisk != nil {
			if respData1.LaunchTemplateVersionData.SystemDisk.DiskType != nil {
				systemDiskMap["disk_type"] = respData1.LaunchTemplateVersionData.SystemDisk.DiskType
			}

			if respData1.LaunchTemplateVersionData.SystemDisk.DiskId != nil {
				systemDiskMap["disk_id"] = respData1.LaunchTemplateVersionData.SystemDisk.DiskId
			}

			if respData1.LaunchTemplateVersionData.SystemDisk.DiskSize != nil {
				systemDiskMap["disk_size"] = respData1.LaunchTemplateVersionData.SystemDisk.DiskSize
			}

			if respData1.LaunchTemplateVersionData.SystemDisk.CdcId != nil {
				systemDiskMap["cdc_id"] = respData1.LaunchTemplateVersionData.SystemDisk.CdcId
			}

			_ = d.Set("system_disk", []interface{}{systemDiskMap})
		}

		dataDisksList := make([]map[string]interface{}, 0, len(respData1.LaunchTemplateVersionData.DataDisks))
		if respData1.LaunchTemplateVersionData.DataDisks != nil {
			for _, dataDisks := range respData1.LaunchTemplateVersionData.DataDisks {
				dataDisksMap := map[string]interface{}{}

				if dataDisks.DiskSize != nil {
					dataDisksMap["disk_size"] = dataDisks.DiskSize
				}

				if dataDisks.DiskType != nil {
					dataDisksMap["disk_type"] = dataDisks.DiskType
				}

				if dataDisks.DiskId != nil {
					dataDisksMap["disk_id"] = dataDisks.DiskId
				}

				if dataDisks.DeleteWithInstance != nil {
					dataDisksMap["delete_with_instance"] = dataDisks.DeleteWithInstance
				}

				if dataDisks.SnapshotId != nil {
					dataDisksMap["snapshot_id"] = dataDisks.SnapshotId
				}

				if dataDisks.Encrypt != nil {
					dataDisksMap["encrypt"] = dataDisks.Encrypt
				}

				if dataDisks.KmsKeyId != nil {
					dataDisksMap["kms_key_id"] = dataDisks.KmsKeyId
				}

				if dataDisks.ThroughputPerformance != nil {
					dataDisksMap["throughput_performance"] = dataDisks.ThroughputPerformance
				}

				if dataDisks.CdcId != nil {
					dataDisksMap["cdc_id"] = dataDisks.CdcId
				}

				dataDisksList = append(dataDisksList, dataDisksMap)
			}

			_ = d.Set("data_disks", dataDisksList)
		}
		internetAccessibleMap := map[string]interface{}{}

		if respData1.LaunchTemplateVersionData.InternetAccessible != nil {
			if respData1.LaunchTemplateVersionData.InternetAccessible.InternetChargeType != nil {
				internetAccessibleMap["internet_charge_type"] = respData1.LaunchTemplateVersionData.InternetAccessible.InternetChargeType
			}

			if respData1.LaunchTemplateVersionData.InternetAccessible.InternetMaxBandwidthOut != nil {
				internetAccessibleMap["internet_max_bandwidth_out"] = respData1.LaunchTemplateVersionData.InternetAccessible.InternetMaxBandwidthOut
			}

			if respData1.LaunchTemplateVersionData.InternetAccessible.PublicIpAssigned != nil {
				internetAccessibleMap["public_ip_assigned"] = respData1.LaunchTemplateVersionData.InternetAccessible.PublicIpAssigned
			}

			if respData1.LaunchTemplateVersionData.InternetAccessible.BandwidthPackageId != nil {
				internetAccessibleMap["bandwidth_package_id"] = respData1.LaunchTemplateVersionData.InternetAccessible.BandwidthPackageId
			}

			_ = d.Set("internet_accessible", []interface{}{internetAccessibleMap})
		}

		virtualPrivateCloudMap := map[string]interface{}{}

		if respData1.LaunchTemplateVersionData.VirtualPrivateCloud != nil {
			if respData1.LaunchTemplateVersionData.VirtualPrivateCloud.VpcId != nil {
				virtualPrivateCloudMap["vpc_id"] = respData1.LaunchTemplateVersionData.VirtualPrivateCloud.VpcId
			}

			if respData1.LaunchTemplateVersionData.VirtualPrivateCloud.SubnetId != nil {
				virtualPrivateCloudMap["subnet_id"] = respData1.LaunchTemplateVersionData.VirtualPrivateCloud.SubnetId
			}

			if respData1.LaunchTemplateVersionData.VirtualPrivateCloud.AsVpcGateway != nil {
				virtualPrivateCloudMap["as_vpc_gateway"] = respData1.LaunchTemplateVersionData.VirtualPrivateCloud.AsVpcGateway
			}

			if respData1.LaunchTemplateVersionData.VirtualPrivateCloud.PrivateIpAddresses != nil {
				virtualPrivateCloudMap["private_ip_addresses"] = respData1.LaunchTemplateVersionData.VirtualPrivateCloud.PrivateIpAddresses
			}

			if respData1.LaunchTemplateVersionData.VirtualPrivateCloud.Ipv6AddressCount != nil {
				virtualPrivateCloudMap["ipv6_address_count"] = respData1.LaunchTemplateVersionData.VirtualPrivateCloud.Ipv6AddressCount
			}

			_ = d.Set("virtual_private_cloud", []interface{}{virtualPrivateCloudMap})
		}

		if respData1.LaunchTemplateVersionData.ImageId != nil {
			_ = d.Set("image_id", respData1.LaunchTemplateVersionData.ImageId)
		}

		if respData1.LaunchTemplateVersionData.SecurityGroupIds != nil {
			_ = d.Set("security_group_ids", respData1.LaunchTemplateVersionData.SecurityGroupIds)
		}

		loginSettingsMap := map[string]interface{}{}

		if respData1.LaunchTemplateVersionData.LoginSettings != nil {
			if respData1.LaunchTemplateVersionData.LoginSettings.Password != nil {
				loginSettingsMap["password"] = respData1.LaunchTemplateVersionData.LoginSettings.Password
			}

			if respData1.LaunchTemplateVersionData.LoginSettings.KeyIds != nil {
				loginSettingsMap["key_ids"] = respData1.LaunchTemplateVersionData.LoginSettings.KeyIds
			}

			if respData1.LaunchTemplateVersionData.LoginSettings.KeepImageLogin != nil {
				loginSettingsMap["keep_image_login"] = respData1.LaunchTemplateVersionData.LoginSettings.KeepImageLogin
			}

			_ = d.Set("login_settings", []interface{}{loginSettingsMap})
		}

		if respData1.LaunchTemplateVersionData.CamRoleName != nil {
			_ = d.Set("cam_role_name", respData1.LaunchTemplateVersionData.CamRoleName)
		}

		if respData1.LaunchTemplateVersionData.HpcClusterId != nil {
			_ = d.Set("hpc_cluster_id", respData1.LaunchTemplateVersionData.HpcClusterId)
		}

		if respData1.LaunchTemplateVersionData.InstanceCount != nil {
			_ = d.Set("instance_count", respData1.LaunchTemplateVersionData.InstanceCount)
		}

		enhancedServiceMap := map[string]interface{}{}

		if respData1.LaunchTemplateVersionData.EnhancedService != nil {
			securityServiceMap := map[string]interface{}{}

			if respData1.LaunchTemplateVersionData.EnhancedService.SecurityService != nil {
				if respData1.LaunchTemplateVersionData.EnhancedService.SecurityService.Enabled != nil {
					securityServiceMap["enabled"] = respData1.LaunchTemplateVersionData.EnhancedService.SecurityService.Enabled
				}

				enhancedServiceMap["security_service"] = []interface{}{securityServiceMap}
			}

			monitorServiceMap := map[string]interface{}{}

			if respData1.LaunchTemplateVersionData.EnhancedService.MonitorService != nil {
				if respData1.LaunchTemplateVersionData.EnhancedService.MonitorService.Enabled != nil {
					monitorServiceMap["enabled"] = respData1.LaunchTemplateVersionData.EnhancedService.MonitorService.Enabled
				}

				enhancedServiceMap["monitor_service"] = []interface{}{monitorServiceMap}
			}

			automationServiceMap := map[string]interface{}{}

			if respData1.LaunchTemplateVersionData.EnhancedService.AutomationService != nil {
				if respData1.LaunchTemplateVersionData.EnhancedService.AutomationService.Enabled != nil {
					automationServiceMap["enabled"] = respData1.LaunchTemplateVersionData.EnhancedService.AutomationService.Enabled
				}

				enhancedServiceMap["automation_service"] = []interface{}{automationServiceMap}
			}

			_ = d.Set("enhanced_service", []interface{}{enhancedServiceMap})
		}

		if respData1.LaunchTemplateVersionData.UserData != nil {
			_ = d.Set("user_data", respData1.LaunchTemplateVersionData.UserData)
		}

		if respData1.LaunchTemplateVersionData.DisasterRecoverGroupIds != nil {
			_ = d.Set("disaster_recover_group_ids", respData1.LaunchTemplateVersionData.DisasterRecoverGroupIds)
		}

		actionTimerMap := map[string]interface{}{}

		if respData1.LaunchTemplateVersionData.ActionTimer != nil {
			if respData1.LaunchTemplateVersionData.ActionTimer.TimerAction != nil {
				actionTimerMap["timer_action"] = respData1.LaunchTemplateVersionData.ActionTimer.TimerAction
			}

			if respData1.LaunchTemplateVersionData.ActionTimer.ActionTime != nil {
				actionTimerMap["action_time"] = respData1.LaunchTemplateVersionData.ActionTimer.ActionTime
			}

			externalsMap := map[string]interface{}{}

			if respData1.LaunchTemplateVersionData.ActionTimer.Externals != nil {
				if respData1.LaunchTemplateVersionData.ActionTimer.Externals.ReleaseAddress != nil {
					externalsMap["release_address"] = respData1.LaunchTemplateVersionData.ActionTimer.Externals.ReleaseAddress
				}

				if respData1.LaunchTemplateVersionData.ActionTimer.Externals.UnsupportNetworks != nil {
					externalsMap["unsupport_networks"] = respData1.LaunchTemplateVersionData.ActionTimer.Externals.UnsupportNetworks
				}

				storageBlockAttrMap := map[string]interface{}{}

				if respData1.LaunchTemplateVersionData.ActionTimer.Externals.StorageBlockAttr != nil {
					if respData1.LaunchTemplateVersionData.ActionTimer.Externals.StorageBlockAttr.Type != nil {
						storageBlockAttrMap["type"] = respData1.LaunchTemplateVersionData.ActionTimer.Externals.StorageBlockAttr.Type
					}

					if respData1.LaunchTemplateVersionData.ActionTimer.Externals.StorageBlockAttr.MinSize != nil {
						storageBlockAttrMap["min_size"] = respData1.LaunchTemplateVersionData.ActionTimer.Externals.StorageBlockAttr.MinSize
					}

					if respData1.LaunchTemplateVersionData.ActionTimer.Externals.StorageBlockAttr.MaxSize != nil {
						storageBlockAttrMap["max_size"] = respData1.LaunchTemplateVersionData.ActionTimer.Externals.StorageBlockAttr.MaxSize
					}

					externalsMap["storage_block_attr"] = []interface{}{storageBlockAttrMap}
				}

				actionTimerMap["externals"] = []interface{}{externalsMap}
			}

			_ = d.Set("action_timer", []interface{}{actionTimerMap})
		}

		instanceMarketOptionsMap := map[string]interface{}{}

		if respData1.LaunchTemplateVersionData.InstanceMarketOptions != nil {
			spotOptionsMap := map[string]interface{}{}

			if respData1.LaunchTemplateVersionData.InstanceMarketOptions.SpotOptions != nil {
				if respData1.LaunchTemplateVersionData.InstanceMarketOptions.SpotOptions.MaxPrice != nil {
					spotOptionsMap["max_price"] = respData1.LaunchTemplateVersionData.InstanceMarketOptions.SpotOptions.MaxPrice
				}

				if respData1.LaunchTemplateVersionData.InstanceMarketOptions.SpotOptions.SpotInstanceType != nil {
					spotOptionsMap["spot_instance_type"] = respData1.LaunchTemplateVersionData.InstanceMarketOptions.SpotOptions.SpotInstanceType
				}

				instanceMarketOptionsMap["spot_options"] = []interface{}{spotOptionsMap}
			}

			if respData1.LaunchTemplateVersionData.InstanceMarketOptions.MarketType != nil {
				instanceMarketOptionsMap["market_type"] = respData1.LaunchTemplateVersionData.InstanceMarketOptions.MarketType
			}

			_ = d.Set("instance_market_options", []interface{}{instanceMarketOptionsMap})
		}

		if respData1.LaunchTemplateVersionData.HostName != nil {
			_ = d.Set("host_name", respData1.LaunchTemplateVersionData.HostName)
		}

		if respData1.LaunchTemplateVersionData.ClientToken != nil {
			_ = d.Set("client_token", respData1.LaunchTemplateVersionData.ClientToken)
		}

		instanceChargePrepaidMap := map[string]interface{}{}

		if respData1.LaunchTemplateVersionData.InstanceChargePrepaid != nil {
			if respData1.LaunchTemplateVersionData.InstanceChargePrepaid.Period != nil {
				instanceChargePrepaidMap["period"] = respData1.LaunchTemplateVersionData.InstanceChargePrepaid.Period
			}

			if respData1.LaunchTemplateVersionData.InstanceChargePrepaid.RenewFlag != nil {
				instanceChargePrepaidMap["renew_flag"] = respData1.LaunchTemplateVersionData.InstanceChargePrepaid.RenewFlag
			}

			_ = d.Set("instance_charge_prepaid", []interface{}{instanceChargePrepaidMap})
		}

		tagSpecificationList := make([]map[string]interface{}, 0, len(respData1.LaunchTemplateVersionData.TagSpecification))
		if respData1.LaunchTemplateVersionData.TagSpecification != nil {
			for _, tagSpecification := range respData1.LaunchTemplateVersionData.TagSpecification {
				tagSpecificationMap := map[string]interface{}{}

				if tagSpecification.ResourceType != nil {
					tagSpecificationMap["resource_type"] = tagSpecification.ResourceType
				}

				tagsList := make([]map[string]interface{}, 0, len(tagSpecification.Tags))
				if tagSpecification.Tags != nil {
					for _, tags := range tagSpecification.Tags {
						tagsMap := map[string]interface{}{}

						if tags.Key != nil {
							tagsMap["key"] = tags.Key
						}

						if tags.Value != nil {
							tagsMap["value"] = tags.Value
						}

						tagsList = append(tagsList, tagsMap)
					}

					tagSpecificationMap["tags"] = tagsList
				}
				tagSpecificationList = append(tagSpecificationList, tagSpecificationMap)
			}

			_ = d.Set("tag_specification", tagSpecificationList)
		}
	}

	if respData1.LaunchTemplateVersionDescription != nil {
		_ = d.Set("launch_template_version_description", respData1.LaunchTemplateVersionDescription)
	}

	return nil
}

func resourceTencentCloudCvmLaunchTemplateDelete(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_cvm_launch_template.delete")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)
	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	launchTemplateId := d.Id()

	var (
		request  = cvm.NewDeleteLaunchTemplateRequest()
		response = cvm.NewDeleteLaunchTemplateResponse()
	)

	request.LaunchTemplateId = helper.String(launchTemplateId)

	err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCvmClient().DeleteLaunchTemplateWithContext(ctx, request)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
		}
		response = result
		return nil
	})
	if err != nil {
		log.Printf("[CRITAL]%s delete cvm launch template failed, reason:%+v", logId, err)
		return err
	}

	_ = response
	return nil
}
