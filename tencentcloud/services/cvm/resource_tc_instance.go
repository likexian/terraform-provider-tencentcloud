// Code generated by iacg; DO NOT EDIT.
package cvm

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	cvmv20170312 "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/cvm/v20170312"
	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
	"log"
	"time"
)

func ResourceTencentCloudInstance() *schema.Resource {
	return &schema.Resource{
		Create: resourceTencentCloudInstanceCreate,
		Read:   resourceTencentCloudInstanceRead,
		Update: resourceTencentCloudInstanceUpdate,
		Delete: resourceTencentCloudInstanceDelete,
		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(900000 * time.Millisecond),
		},
		Importer: &schema.ResourceImporter{
			State: schema.ImportStatePassthrough,
		},
		Schema: map[string]*schema.Schema{
			"image_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "The image to use for the instance. Changing `image_id` will cause the instance reset.",
			},

			"availability_zone": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: "The available zone for the CVM instance.",
			},

			"instance_count": {
				Type:         schema.TypeInt,
				Optional:     true,
				Description:  "The number of instances to be purchased. Value range:[1,100]; default value: 1.",
				Deprecated:   "It has been deprecated from version 1.59.18. Use built-in `count` instead.",
				ValidateFunc: tccommon.ValidateIntegerInRange(1, 100),
			},

			"instance_name": {
				Type:         schema.TypeString,
				Optional:     true,
				Default:      "Terraform-CVM-Instance",
				Description:  "The name of the instance. The max length of instance_name is 60, and default value is `Terraform-CVM-Instance`.",
				ValidateFunc: tccommon.ValidateStringLengthInRange(2, 128),
			},

			"instance_type": {
				Type:         schema.TypeString,
				Optional:     true,
				Computed:     true,
				Description:  "The type of the instance.",
				ValidateFunc: tccommon.ValidateInstanceType,
			},

			"hostname": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "The hostname of the instance. Windows instance: The name should be a combination of 2 to 15 characters comprised of letters (case insensitive), numbers, and hyphens (-). Period (.) is not supported, and the name cannot be a string of pure numbers. Other types (such as Linux) of instances: The name should be a combination of 2 to 60 characters, supporting multiple periods (.). The piece between two periods is composed of letters (case insensitive), numbers, and hyphens (-). Modifying will cause the instance reset.",
			},

			"project_id": {
				Type:        schema.TypeInt,
				Optional:    true,
				Default:     0,
				Description: "The project the instance belongs to, default to 0.",
			},

			"running_flag": {
				Type:        schema.TypeBool,
				Optional:    true,
				Default:     true,
				Description: "Set instance to running or stop. Default value is true, the instance will shutdown when this flag is false.",
			},

			"stopped_mode": {
				Type:         schema.TypeString,
				Optional:     true,
				Description:  "Billing method of a pay-as-you-go instance after shutdown. Available values: `KEEP_CHARGING`,`STOP_CHARGING`. Default `KEEP_CHARGING`.",
				ValidateFunc: tccommon.ValidateAllowedStringValue([]string{CVM_STOP_MODE_KEEP_CHARGING, CVM_STOP_MODE_STOP_CHARGING}),
			},

			"placement_group_id": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: "The ID of a placement group.",
			},

			"instance_charge_type": {
				Type:         schema.TypeString,
				Optional:     true,
				Default:      "POSTPAID_BY_HOUR",
				Description:  "The charge type of instance. Valid values are `PREPAID`, `POSTPAID_BY_HOUR`, `SPOTPAID` and `CDHPAID`. The default is `POSTPAID_BY_HOUR`. Note: TencentCloud International only supports `POSTPAID_BY_HOUR` and `CDHPAID`. `PREPAID` instance may not allow to delete before expired. `SPOTPAID` instance must set `spot_instance_type` and `spot_max_price` at the same time. `CDHPAID` instance must set `cdh_instance_type` and `cdh_host_id`.",
				ValidateFunc: tccommon.ValidateAllowedStringValue(CVM_CHARGE_TYPE),
			},

			"instance_charge_type_prepaid_period": {
				Type:         schema.TypeInt,
				Optional:     true,
				Description:  "The tenancy (time unit is month) of the prepaid instance, NOTE: it only works when instance_charge_type is set to `PREPAID`. Valid values are `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10`, `11`, `12`, `24`, `36`.",
				ValidateFunc: tccommon.ValidateAllowedIntValue(CVM_PREPAID_PERIOD),
			},

			"instance_charge_type_prepaid_renew_flag": {
				Type:         schema.TypeString,
				Optional:     true,
				Computed:     true,
				Description:  "Auto renewal flag. Valid values: `NOTIFY_AND_AUTO_RENEW`: notify upon expiration and renew automatically, `NOTIFY_AND_MANUAL_RENEW`: notify upon expiration but do not renew automatically, `DISABLE_NOTIFY_AND_MANUAL_RENEW`: neither notify upon expiration nor renew automatically. Default value: `NOTIFY_AND_MANUAL_RENEW`. If this parameter is specified as `NOTIFY_AND_AUTO_RENEW`, the instance will be automatically renewed on a monthly basis if the account balance is sufficient. NOTE: it only works when instance_charge_type is set to `PREPAID`.",
				ValidateFunc: tccommon.ValidateAllowedStringValue(CVM_PREPAID_RENEW_FLAG),
			},

			"spot_instance_type": {
				Type:         schema.TypeString,
				Optional:     true,
				Description:  "Type of spot instance, only support `ONE-TIME` now. Note: it only works when instance_charge_type is set to `SPOTPAID`.",
				ValidateFunc: tccommon.ValidateAllowedStringValue(CVM_SPOT_INSTANCE_TYPE),
			},

			"spot_max_price": {
				Type:         schema.TypeString,
				Optional:     true,
				ForceNew:     true,
				Description:  "Max price of a spot instance, is the format of decimal string, for example \"0.50\". Note: it only works when instance_charge_type is set to `SPOTPAID`.",
				ValidateFunc: tccommon.ValidateStringNumber,
			},

			"cdh_instance_type": {
				Type:         schema.TypeString,
				Optional:     true,
				Description:  "Type of instance created on cdh, the value of this parameter is in the format of CDH_XCXG based on the number of CPU cores and memory capacity. Note: it only works when instance_charge_type is set to `CDHPAID`.",
				ValidateFunc: tccommon.ValidateStringPrefix("CDH_"),
			},

			"cdh_host_id": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: "Id of cdh instance. Note: it only works when instance_charge_type is set to `CDHPAID`.",
			},

			"internet_charge_type": {
				Type:             schema.TypeString,
				Optional:         true,
				Computed:         true,
				Description:      "Internet charge type of the instance, Valid values are `BANDWIDTH_PREPAID`, `TRAFFIC_POSTPAID_BY_HOUR`, `BANDWIDTH_POSTPAID_BY_HOUR` and `BANDWIDTH_PACKAGE`. If not set, internet charge type are consistent with the cvm charge type by default. This value takes NO Effect when changing and does not need to be set when `allocate_public_ip` is false.",
				ValidateFunc:     tccommon.ValidateAllowedStringValue(CVM_INTERNET_CHARGE_TYPE),
				DiffSuppressFunc: internetChargeType,
			},

			"bandwidth_package_id": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "bandwidth package id. if user is standard user, then the bandwidth_package_id is needed, or default has bandwidth_package_id.",
			},

			"internet_max_bandwidth_out": {
				Type:        schema.TypeInt,
				Optional:    true,
				Computed:    true,
				Description: "Maximum outgoing bandwidth to the public network, measured in Mbps (Mega bits per second). This value does not need to be set when `allocate_public_ip` is false.",
			},

			"allocate_public_ip": {
				Type:        schema.TypeBool,
				Optional:    true,
				ForceNew:    true,
				Default:     false,
				Description: "Associate a public IP address with an instance in a VPC or Classic. Boolean value, Default is false.",
			},

			"vpc_id": {
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
				Description: "The ID of a VPC network. If you want to create instances in a VPC network, this parameter must be set.",
			},

			"subnet_id": {
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
				Description: "The ID of a VPC subnet. If you want to create instances in a VPC network, this parameter must be set.",
			},

			"private_ip": {
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
				Description: "The private IP to be assigned to this instance, must be in the provided subnet and available.",
			},

			"security_groups": {
				Type:          schema.TypeSet,
				Optional:      true,
				Computed:      true,
				ConflictsWith: []string{"orderly_security_groups"},
				Description:   "A list of security group IDs to associate with.",
				Deprecated:    "It will be deprecated. Use `orderly_security_groups` instead.",
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},

			"orderly_security_groups": {
				Type:          schema.TypeList,
				Optional:      true,
				Computed:      true,
				ConflictsWith: []string{"security_groups"},
				Description:   "A list of orderly security group IDs to associate with.",
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},

			"system_disk_type": {
				Type:         schema.TypeString,
				Optional:     true,
				Default:      "CLOUD_PREMIUM",
				Description:  "System disk type. For more information on limits of system disk types, see [Storage Overview](https://intl.cloud.tencent.com/document/product/213/4952). Valid values: `LOCAL_BASIC`: local disk, `LOCAL_SSD`: local SSD disk, `CLOUD_BASIC`: cloud disk, `CLOUD_SSD`: cloud SSD disk, `CLOUD_PREMIUM`: Premium Cloud Storage, `CLOUD_BSSD`: Basic SSD, `CLOUD_HSSD`: Enhanced SSD, `CLOUD_TSSD`: Tremendous SSD. NOTE: If modified, the instance may force stop.",
				ValidateFunc: tccommon.ValidateAllowedStringValue(CVM_DISK_TYPE),
			},

			"system_disk_size": {
				Type:        schema.TypeInt,
				Optional:    true,
				Default:     50,
				Description: "Size of the system disk. unit is GB, Default is 50GB. If modified, the instance may force stop.",
			},

			"system_disk_id": {
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
				Description: "System disk snapshot ID used to initialize the system disk. When system disk type is `LOCAL_BASIC` and `LOCAL_SSD`, disk id is not supported.",
			},

			"data_disks": {
				Type:        schema.TypeList,
				Optional:    true,
				Computed:    true,
				ForceNew:    true,
				Description: "Settings for data disks.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"data_disk_type": {
							Type:        schema.TypeString,
							Required:    true,
							ForceNew:    true,
							Description: "Data disk type. For more information about limits on different data disk types, see [Storage Overview](https://intl.cloud.tencent.com/document/product/213/4952). Valid values: LOCAL_BASIC: local disk, LOCAL_SSD: local SSD disk, LOCAL_NVME: local NVME disk, specified in the InstanceType, LOCAL_PRO: local HDD disk, specified in the InstanceType, CLOUD_BASIC: HDD cloud disk, CLOUD_PREMIUM: Premium Cloud Storage, CLOUD_SSD: SSD, CLOUD_HSSD: Enhanced SSD, CLOUD_TSSD: Tremendous SSD, CLOUD_BSSD: Balanced SSD.",
						},
						"data_disk_size": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "Size of the data disk, and unit is GB.",
						},
						"data_disk_snapshot_id": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: "Snapshot ID of the data disk. The selected data disk snapshot size must be smaller than the data disk size.",
						},
						"data_disk_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Data disk ID used to initialize the data disk. When data disk type is `LOCAL_BASIC` and `LOCAL_SSD`, disk id is not supported.",
						},
						"delete_with_instance": {
							Type:        schema.TypeBool,
							Optional:    true,
							ForceNew:    true,
							Default:     true,
							Description: "Decides whether the disk is deleted with instance(only applied to `CLOUD_BASIC`, `CLOUD_SSD` and `CLOUD_PREMIUM` disk with `POSTPAID_BY_HOUR` instance), default is true.",
						},
						"encrypt": {
							Type:        schema.TypeBool,
							Optional:    true,
							ForceNew:    true,
							Default:     false,
							Description: "Decides whether the disk is encrypted. Default is `false`.",
						},
						"throughput_performance": {
							Type:        schema.TypeInt,
							Optional:    true,
							ForceNew:    true,
							Default:     0,
							Description: "Add extra performance to the data disk. Only works when disk type is `CLOUD_TSSD` or `CLOUD_HSSD`.",
						},
					},
				},
			},

			"disable_security_service": {
				Type:        schema.TypeBool,
				Optional:    true,
				Default:     false,
				Description: "Disable enhance service for security, it is enabled by default. When this options is set, security agent won't be installed. Modifying will cause the instance reset.",
			},

			"disable_monitor_service": {
				Type:        schema.TypeBool,
				Optional:    true,
				Default:     false,
				Description: "Disable enhance service for monitor, it is enabled by default. When this options is set, monitor agent won't be installed. Modifying will cause the instance reset.",
			},

			"key_name": {
				Type:          schema.TypeString,
				Optional:      true,
				Computed:      true,
				ConflictsWith: []string{"key_ids"},
				Description:   "The key pair to use for the instance, it looks like `skey-16jig7tx`. Modifying will cause the instance reset.",
				Deprecated:    "Please use `key_ids` instead.",
			},

			"key_ids": {
				Type:          schema.TypeSet,
				Optional:      true,
				Computed:      true,
				ConflictsWith: []string{"key_name", "password"},
				Description:   "The key pair to use for the instance, it looks like `skey-16jig7tx`. Modifying will cause the instance reset.",
				Set:           schema.HashString,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},

			"password": {
				Type:        schema.TypeString,
				Optional:    true,
				Sensitive:   true,
				Description: "Password for the instance. In order for the new password to take effect, the instance will be restarted after the password change. Modifying will cause the instance reset.",
			},

			"keep_image_login": {
				Type:             schema.TypeBool,
				Optional:         true,
				Default:          false,
				ConflictsWith:    []string{"key_name", "key_ids", "password"},
				Description:      "Whether to keep image login or not, default is `false`. When the image type is private or shared or imported, this parameter can be set `true`. Modifying will cause the instance reset.",
				DiffSuppressFunc: keepImageLogin,
			},

			"user_data": {
				Type:          schema.TypeString,
				Optional:      true,
				ForceNew:      true,
				ConflictsWith: []string{"user_data_raw"},
				Description:   "The user data to be injected into this instance. Must be base64 encoded and up to 16 KB.",
			},

			"user_data_raw": {
				Type:          schema.TypeString,
				Optional:      true,
				ForceNew:      true,
				ConflictsWith: []string{"user_data"},
				Description:   "The user data to be injected into this instance, in plain text. Conflicts with `user_data`. Up to 16 KB after base64 encoded.",
			},

			"tags": {
				Type:        schema.TypeMap,
				Optional:    true,
				Description: "A mapping of tags to assign to the resource. For tag limits, please refer to [Use Limits](https://intl.cloud.tencent.com/document/product/651/13354).",
			},

			"force_delete": {
				Type:        schema.TypeBool,
				Optional:    true,
				Default:     false,
				Description: "Indicate whether to force delete the instance. Default is `false`. If set true, the instance will be permanently deleted instead of being moved into the recycle bin. Note: only works for `PREPAID` instance.",
			},

			"disable_api_termination": {
				Type:        schema.TypeBool,
				Optional:    true,
				Default:     false,
				Description: "Whether the termination protection is enabled. Default is `false`. If set true, which means that this instance can not be deleted by an API action.",
			},

			"cam_role_name": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: "CAM role name authorized to access.",
			},

			"instance_status": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "Current status of the instance.",
			},

			"public_ip": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "Public IP of the instance.",
			},

			"uuid": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "Globally unique ID of the instance.",
			},

			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "Create time of the instance.",
			},

			"expired_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "Expired time of the instance.",
			},

			"cpu": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: "The number of CPU cores of the instance.",
			},

			"memory": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: "Instance memory capacity, unit in GB.",
			},

			"os_name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "Instance os name.",
			},
		},
	}
}

func resourceTencentCloudInstanceCreate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_instance.create")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	var (
		instanceId string
	)
	var (
		request  = cvmv20170312.NewRunInstancesRequest()
		response = cvmv20170312.NewRunInstancesResponse()
	)

	if v, ok := d.GetOk("image_id"); ok {
		request.ImageId = helper.String(v.(string))
	}

	placement := cvmv20170312.Placement{}
	if v, ok := d.GetOk("availability_zone"); ok {
		placement.Zone = helper.String(v.(string))
	}
	if v, ok := d.GetOkExists("project_id"); ok {
		placement.ProjectId = helper.IntInt64(v.(int))
	}
	request.Placement = &placement

	if v, ok := d.GetOk("instance_name"); ok {
		request.InstanceName = helper.String(v.(string))
	}

	if v, ok := d.GetOkExists("instance_count"); ok {
		request.InstanceCount = helper.IntInt64(v.(int))
	}

	if v, ok := d.GetOk("instance_type"); ok {
		request.InstanceType = helper.String(v.(string))
	}

	if v, ok := d.GetOk("hostname"); ok {
		request.HostName = helper.String(v.(string))
	}

	if v, ok := d.GetOk("cam_role_name"); ok {
		request.CamRoleName = helper.String(v.(string))
	}

	internetAccessible := cvmv20170312.InternetAccessible{}
	if v, ok := d.GetOk("internet_charge_type"); ok {
		internetAccessible.InternetChargeType = helper.String(v.(string))
	}
	if v, ok := d.GetOkExists("internet_max_bandwidth_out"); ok {
		internetAccessible.InternetMaxBandwidthOut = helper.IntInt64(v.(int))
	}
	if v, ok := d.GetOk("bandwidth_package_id"); ok {
		internetAccessible.BandwidthPackageId = helper.String(v.(string))
	}
	if v, ok := d.GetOkExists("allocate_public_ip"); ok {
		internetAccessible.PublicIpAssigned = helper.Bool(v.(bool))
	}
	request.InternetAccessible = &internetAccessible

	if v, ok := d.GetOk("security_groups"); ok {
		securityGroupIdsSet := v.(*schema.Set).List()
		for i := range securityGroupIdsSet {
			securityGroupIds := securityGroupIdsSet[i].(string)
			request.SecurityGroupIds = append(request.SecurityGroupIds, helper.String(securityGroupIds))
		}
	}

	systemDisk := cvmv20170312.SystemDisk{}
	if v, ok := d.GetOk("system_disk_type"); ok {
		systemDisk.DiskType = helper.String(v.(string))
	}
	if v, ok := d.GetOkExists("system_disk_size"); ok {
		systemDisk.DiskSize = helper.IntInt64(v.(int))
	}
	if v, ok := d.GetOk("system_disk_id"); ok {
		systemDisk.DiskId = helper.String(v.(string))
	}
	request.SystemDisk = &systemDisk

	enhancedService := cvmv20170312.EnhancedService{}
	runSecurityServiceEnabled := cvmv20170312.RunSecurityServiceEnabled{}
	if v, ok := d.GetOkExists("disable_security_service"); ok {
		runSecurityServiceEnabled.Enabled = helper.Bool(v.(bool))
	}
	enhancedService.SecurityService = &runSecurityServiceEnabled
	runMonitorServiceEnabled := cvmv20170312.RunMonitorServiceEnabled{}
	if v, ok := d.GetOkExists("disable_monitor_service"); ok {
		runMonitorServiceEnabled.Enabled = helper.Bool(v.(bool))
	}
	enhancedService.MonitorService = &runMonitorServiceEnabled
	request.EnhancedService = &enhancedService

	loginSettings := cvmv20170312.LoginSettings{}
	if v, ok := d.GetOk("password"); ok {
		loginSettings.Password = helper.String(v.(string))
	}
	request.LoginSettings = &loginSettings

	if v, ok := d.GetOk("user_data"); ok {
		request.UserData = helper.String(v.(string))
	}

	if v, ok := d.GetOkExists("disable_api_termination"); ok {
		request.DisableApiTermination = helper.Bool(v.(bool))
	}

	if err := resourceTencentCloudInstanceCreatePostFillRequest0(ctx, request); err != nil {
		return err
	}

	err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
		if err := resourceTencentCloudInstanceCreatePreRequest0(ctx, request); err != nil {
			return err
		}

		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCvmV20170312Client().RunInstancesWithContext(ctx, request)
		if e != nil {
			if err := resourceTencentCloudInstanceCreateRequestOnError0(ctx, request, e); err != nil {
				return err
			}
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
		}
		response = result
		return nil
	})
	if err != nil {
		log.Printf("[CRITAL]%s create instance failed, reason:%+v", logId, err)
		return err
	}

	if len(response.Response.InstanceIdSet) < 1 {
		return fmt.Errorf("resource `tencentcloud_instance` create failed.")
	}

	instanceId = *response.Response.InstanceIdSet[0]

	if err := resourceTencentCloudInstanceCreatePostHandleResponse0(ctx, response); err != nil {
		return err
	}

	d.SetId(instanceId)

	return resourceTencentCloudInstanceRead(d, meta)
}

func resourceTencentCloudInstanceRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_instance.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	service := CvmService{client: meta.(tccommon.ProviderMeta).GetAPIV3Conn()}

	instanceId := d.Id()

	var respData *cvmv20170312.Instance
	reqErr := resource.Retry(tccommon.ReadRetryTimeout, func() *resource.RetryError {
		result, e := service.DescribeInstanceById(ctx, instanceId)
		if e != nil {
			return tccommon.RetryError(e)
		}
		if err := resourceTencentCloudInstanceReadRequestOnSuccess0(ctx, result); err != nil {
			return err
		}
		respData = result
		return nil
	})
	if reqErr != nil {
		log.Printf("[CRITAL]%s read instance failed, reason:%+v", logId, reqErr)
		return reqErr
	}

	if respData == nil {
		d.SetId("")
		log.Printf("[WARN]%s resource `instance` [%s] not found, please check if it has been deleted.\n", logId, d.Id())
		return nil
	}
	if err := resourceTencentCloudInstanceReadPreHandleResponse0(ctx, respData); err != nil {
		return err
	}

	if respData.Placement != nil {
		if respData.Placement.Zone != nil {
			_ = d.Set("availability_zone", respData.Placement.Zone)
		}

		if respData.Placement.ProjectId != nil {
			_ = d.Set("project_id", respData.Placement.ProjectId)
		}

	}

	if respData.InstanceName != nil {
		_ = d.Set("instance_name", respData.InstanceName)
	}

	if respData.InstanceType != nil {
		_ = d.Set("instance_type", respData.InstanceType)
	}

	if respData.InstanceChargeType != nil {
		_ = d.Set("instance_charge_type", respData.InstanceChargeType)
	}

	if respData.RenewFlag != nil {
		_ = d.Set("instance_charge_type_prepaid_renew_flag", respData.RenewFlag)
	}

	if respData.InternetAccessible != nil {
		if respData.InternetAccessible.InternetChargeType != nil {
			_ = d.Set("internet_charge_type", respData.InternetAccessible.InternetChargeType)
		}

		if respData.InternetAccessible.InternetMaxBandwidthOut != nil {
			_ = d.Set("internet_max_bandwidth_out", respData.InternetAccessible.InternetMaxBandwidthOut)
		}

	}

	if respData.VirtualPrivateCloud != nil {
		if respData.VirtualPrivateCloud.VpcId != nil {
			_ = d.Set("vpc_id", respData.VirtualPrivateCloud.VpcId)
		}

		if respData.VirtualPrivateCloud.SubnetId != nil {
			_ = d.Set("subnet_id", respData.VirtualPrivateCloud.SubnetId)
		}

	}

	if respData.SecurityGroupIds != nil {
		_ = d.Set("security_groups", respData.SecurityGroupIds)
	}

	if respData.SecurityGroupIds != nil {
		_ = d.Set("orderly_security_groups", respData.SecurityGroupIds)
	}

	if respData.SystemDisk != nil {
		if respData.SystemDisk.DiskType != nil {
			_ = d.Set("system_disk_type", respData.SystemDisk.DiskType)
		}

		if respData.SystemDisk.DiskSize != nil {
			_ = d.Set("system_disk_size", respData.SystemDisk.DiskSize)
		}

		if respData.SystemDisk.DiskId != nil {
			_ = d.Set("system_disk_id", respData.SystemDisk.DiskId)
		}

	}

	if respData.InstanceState != nil {
		_ = d.Set("instance_status", respData.InstanceState)
	}

	if respData.CreatedTime != nil {
		_ = d.Set("create_time", respData.CreatedTime)
	}

	if respData.ExpiredTime != nil {
		_ = d.Set("expired_time", respData.ExpiredTime)
	}

	if respData.CamRoleName != nil {
		_ = d.Set("cam_role_name", respData.CamRoleName)
	}

	if respData.DisableApiTermination != nil {
		_ = d.Set("disable_api_termination", respData.DisableApiTermination)
	}

	if respData.CPU != nil {
		_ = d.Set("cpu", respData.CPU)
	}

	if respData.Memory != nil {
		_ = d.Set("memory", respData.Memory)
	}

	if respData.OsName != nil {
		_ = d.Set("os_name", respData.OsName)
	}

	if respData.Uuid != nil {
		_ = d.Set("uuid", respData.Uuid)
	}

	if err := resourceTencentCloudInstanceReadPostHandleResponse0(ctx, respData); err != nil {
		return err
	}

	return nil
}

func resourceTencentCloudInstanceUpdate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_instance.update")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	immutableArgs := []string{"instance_count", "stopped_mode", "spot_instance_type", "internet_charge_type", "bandwidth_package_id", "system_disk_id", "force_delete"}
	for _, v := range immutableArgs {
		if d.HasChange(v) {
			return fmt.Errorf("argument `%s` cannot be changed", v)
		}
	}
	instanceId := d.Id()

	if err := resourceTencentCloudInstanceUpdateOnStart(ctx); err != nil {
		return err
	}

	needChange := false
	mutableArgs := []string{"instance_name"}
	for _, v := range mutableArgs {
		if d.HasChange(v) {
			needChange = true
			break
		}
	}

	if needChange {
		request := cvmv20170312.NewModifyInstancesAttributeRequest()

		request.InstanceIds = []*string{helper.String(instanceId)}

		if v, ok := d.GetOk("instance_name"); ok {
			request.InstanceName = helper.String(v.(string))
		}

		err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCvmV20170312Client().ModifyInstancesAttributeWithContext(ctx, request)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
			}
			return nil
		})
		if err != nil {
			log.Printf("[CRITAL]%s update instance failed, reason:%+v", logId, err)
			return err
		}
	}

	needChange1 := false
	mutableArgs1 := []string{"disable_api_termination"}
	for _, v := range mutableArgs1 {
		if d.HasChange(v) {
			needChange1 = true
			break
		}
	}

	if needChange1 {
		request1 := cvmv20170312.NewModifyInstancesAttributeRequest()

		request1.InstanceIds = []*string{helper.String(instanceId)}

		if v, ok := d.GetOkExists("disable_api_termination"); ok {
			request1.DisableApiTermination = helper.Bool(v.(bool))
		}

		err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCvmV20170312Client().ModifyInstancesAttributeWithContext(ctx, request1)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request1.GetAction(), request1.ToJsonString(), result.ToJsonString())
			}
			return nil
		})
		if err != nil {
			log.Printf("[CRITAL]%s update instance failed, reason:%+v", logId, err)
			return err
		}
	}

	needChange2 := false
	mutableArgs2 := []string{"security_groups"}
	for _, v := range mutableArgs2 {
		if d.HasChange(v) {
			needChange2 = true
			break
		}
	}

	if needChange2 {
		request2 := cvmv20170312.NewModifyInstancesAttributeRequest()

		request2.InstanceIds = []*string{helper.String(instanceId)}

		if v, ok := d.GetOk("security_groups"); ok {
			securityGroupsSet := v.(*schema.Set).List()
			for i := range securityGroupsSet {
				securityGroups := securityGroupsSet[i].(string)
				request2.SecurityGroups = append(request2.SecurityGroups, helper.String(securityGroups))
			}
		}

		err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCvmV20170312Client().ModifyInstancesAttributeWithContext(ctx, request2)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request2.GetAction(), request2.ToJsonString(), result.ToJsonString())
			}
			return nil
		})
		if err != nil {
			log.Printf("[CRITAL]%s update instance failed, reason:%+v", logId, err)
			return err
		}
	}

	needChange3 := false
	mutableArgs3 := []string{"orderly_security_groups"}
	for _, v := range mutableArgs3 {
		if d.HasChange(v) {
			needChange3 = true
			break
		}
	}

	if needChange3 {
		request3 := cvmv20170312.NewModifyInstancesAttributeRequest()

		request3.InstanceIds = []*string{helper.String(instanceId)}

		if v, ok := d.GetOk("orderly_security_groups"); ok {
			securityGroupsSet := v.([]interface{})
			for i := range securityGroupsSet {
				securityGroups := securityGroupsSet[i].(string)
				request3.SecurityGroups = append(request3.SecurityGroups, helper.String(securityGroups))
			}
		}

		err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCvmV20170312Client().ModifyInstancesAttributeWithContext(ctx, request3)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request3.GetAction(), request3.ToJsonString(), result.ToJsonString())
			}
			return nil
		})
		if err != nil {
			log.Printf("[CRITAL]%s update instance failed, reason:%+v", logId, err)
			return err
		}
	}

	needChange4 := false
	mutableArgs4 := []string{"project_id"}
	for _, v := range mutableArgs4 {
		if d.HasChange(v) {
			needChange4 = true
			break
		}
	}

	if needChange4 {
		request4 := cvmv20170312.NewModifyInstancesProjectRequest()

		request4.InstanceIds = []*string{helper.String(instanceId)}

		if v, ok := d.GetOkExists("project_id"); ok {
			request4.ProjectId = helper.IntInt64(v.(int))
		}

		err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCvmV20170312Client().ModifyInstancesProjectWithContext(ctx, request4)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request4.GetAction(), request4.ToJsonString(), result.ToJsonString())
			}
			return nil
		})
		if err != nil {
			log.Printf("[CRITAL]%s update instance failed, reason:%+v", logId, err)
			return err
		}
	}

	needChange5 := false
	mutableArgs5 := []string{"system_disk_size", "system_disk_type"}
	for _, v := range mutableArgs5 {
		if d.HasChange(v) {
			needChange5 = true
			break
		}
	}

	if needChange5 {
		request5 := cvmv20170312.NewResizeInstanceDisksRequest()

		response5 := cvmv20170312.NewResizeInstanceDisksResponse()

		request5.InstanceId = helper.String(instanceId)

		forceStop := true
		request5.ForceStop = &forceStop

		systemDisk := cvmv20170312.SystemDisk{}
		if v, ok := d.GetOkExists("system_disk_size"); ok {
			systemDisk.DiskSize = helper.IntInt64(v.(int))
		}
		if v, ok := d.GetOk("system_disk_type"); ok {
			systemDisk.DiskType = helper.String(v.(string))
		}
		request5.SystemDisk = &systemDisk

		err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCvmV20170312Client().ResizeInstanceDisksWithContext(ctx, request5)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request5.GetAction(), request5.ToJsonString(), result.ToJsonString())
			}
			return nil
		})
		if err != nil {
			log.Printf("[CRITAL]%s update instance failed, reason:%+v", logId, err)
			return err
		}
		if err := resourceTencentCloudInstanceUpdatePreHandleResponse5(ctx, response5); err != nil {
			return err
		}

	}

	needChange6 := false
	mutableArgs6 := []string{"instance_type"}
	for _, v := range mutableArgs6 {
		if d.HasChange(v) {
			needChange6 = true
			break
		}
	}

	if needChange6 {
		request6 := cvmv20170312.NewResetInstancesTypeRequest()

		response6 := cvmv20170312.NewResetInstancesTypeResponse()

		request6.InstanceIds = []*string{helper.String(instanceId)}

		if v, ok := d.GetOk("instance_type"); ok {
			request6.InstanceType = helper.String(v.(string))
		}

		err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCvmV20170312Client().ResetInstancesTypeWithContext(ctx, request6)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request6.GetAction(), request6.ToJsonString(), result.ToJsonString())
			}
			return nil
		})
		if err != nil {
			log.Printf("[CRITAL]%s update instance failed, reason:%+v", logId, err)
			return err
		}
		if err := resourceTencentCloudInstanceUpdatePreHandleResponse6(ctx, response6); err != nil {
			return err
		}

	}

	needChange7 := false
	mutableArgs7 := []string{"cdh_instance_type"}
	for _, v := range mutableArgs7 {
		if d.HasChange(v) {
			needChange7 = true
			break
		}
	}

	if needChange7 {
		request7 := cvmv20170312.NewResetInstancesTypeRequest()

		response7 := cvmv20170312.NewResetInstancesTypeResponse()

		request7.InstanceIds = []*string{helper.String(instanceId)}

		if v, ok := d.GetOk("cdh_instance_type"); ok {
			request7.InstanceType = helper.String(v.(string))
		}

		err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCvmV20170312Client().ResetInstancesTypeWithContext(ctx, request7)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request7.GetAction(), request7.ToJsonString(), result.ToJsonString())
			}
			return nil
		})
		if err != nil {
			log.Printf("[CRITAL]%s update instance failed, reason:%+v", logId, err)
			return err
		}
		if err := resourceTencentCloudInstanceUpdatePreHandleResponse7(ctx, response7); err != nil {
			return err
		}

	}

	needChange8 := false
	mutableArgs8 := []string{"vpc_id", "subnet_id"}
	for _, v := range mutableArgs8 {
		if d.HasChange(v) {
			needChange8 = true
			break
		}
	}

	if needChange8 {
		request8 := cvmv20170312.NewModifyInstancesVpcAttributeRequest()

		request8.InstanceIds = []*string{helper.String(instanceId)}

		virtualPrivateCloud := cvmv20170312.VirtualPrivateCloud{}
		if v, ok := d.GetOk("vpc_id"); ok {
			virtualPrivateCloud.VpcId = helper.String(v.(string))
		}
		if v, ok := d.GetOk("subnet_id"); ok {
			virtualPrivateCloud.SubnetId = helper.String(v.(string))
		}
		request8.VirtualPrivateCloud = &virtualPrivateCloud

		if err := resourceTencentCloudInstanceUpdatePostFillRequest8(ctx, request8); err != nil {
			return err
		}

		err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCvmV20170312Client().ModifyInstancesVpcAttributeWithContext(ctx, request8)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request8.GetAction(), request8.ToJsonString(), result.ToJsonString())
			}
			return nil
		})
		if err != nil {
			log.Printf("[CRITAL]%s update instance failed, reason:%+v", logId, err)
			return err
		}
	}

	if err := resourceTencentCloudInstanceUpdateOnExit(ctx); err != nil {
		return err
	}

	return resourceTencentCloudInstanceRead(d, meta)
}

func resourceTencentCloudInstanceDelete(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_instance.delete")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)
	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	instanceId := d.Id()

	var (
		request  = cvmv20170312.NewTerminateInstancesRequest()
		response = cvmv20170312.NewTerminateInstancesResponse()
	)

	request.InstanceIds = []*string{helper.String(instanceId)}

	if err := resourceTencentCloudInstanceDeletePostFillRequest0(ctx, request); err != nil {
		return err
	}

	err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCvmV20170312Client().TerminateInstancesWithContext(ctx, request)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
		}
		response = result
		return nil
	})
	if err != nil {
		log.Printf("[CRITAL]%s delete instance failed, reason:%+v", logId, err)
		return err
	}

	if err := resourceTencentCloudInstanceDeletePreHandleResponse0(ctx, response); err != nil {
		return err
	}

	_ = response
	return nil
}
