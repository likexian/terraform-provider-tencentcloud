tencentcloud/connectivity/client.go:
  import: "import billing \"github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/billing/v20180709\""
  client: "billingConn        *billing.Client"
  useClient: |
    func (me *TencentCloudClient) UseBillingClient() *billing.Client {
        if me.billingConn != nil {
          return me.billingConn
        }

        cpf := me.NewClientProfile(300)
        me.billingConn, _ = billing.NewClient(me.Credential, me.Region, cpf)
        me.billingConn.WithHttpTransport(&LogRoundTripper{})

        return me.billingConn
    }

tencentcloud/services/billing/extension_billing.go:
  all: |
    package billing

    var TRADE_RETRYABLE_ERROR = []string{
      "InternalError.TradeError",  //mysql
      "FailedOperation.PayFailed", //redis
    }

    // deal status: https://cloud.tencent.com/document/product/555/19179

    var DEAL_STATUS_CODE = []int64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}

    var DEAL_TERMINATE_STATUS_CODE = []int64{4, 5, 6, 7, 8, 9, 10, 11}

tencentcloud/internal/helper/transform.go:
  boolStr: |
    func BoolToStr(b bool) (s string) {
      s = "false"
      if b {
        s = "true"
      }
      return
    }
tencentcloud/provider.go:
  envYunti: "	PROVIDER_ENABLE_YUNTI                 = \"TENCENTCLOUD_ENABLE_YUNTI\""
  enableBpass: |
    "enable_bpass": {
    Type:        schema.TypeBool,
    Optional:    true,
    Default:     false,
    DefaultFunc: schema.EnvDefaultFunc(PROVIDER_ENABLE_YUNTI, nil),
    Description: "Use the yunti account or not, Default is `false`.",
    },


tencentcloud/services/cynosdb/resource_tc_cynosdb_cluster.go:
  import: "import \"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/services/billing\""
  client: |
    billingService = billing.BillingService{Client: client}
  varId: "	var id string"
  varCharge: "	var chargeTypeStr string"
  strCharge: "		chargeTypeStr = v.(string)"
  bpass: |
    if chargeTypeStr == CYNOSDB_CHARGE_TYPE_PREPAID {
    	regx := "\"dealNames\":\\\[\"(.*)\"\\\]"
    	// query deal by bpass
    	resourceId, billErr := billingService.QueryDealByBpass(ctx, regx, err)
    	if billErr != nil {
    		log.Printf("[CRITAL]%s api[QueryDealByBpass] fail, reason[%s]\\n", logId, billErr.Error())
    		return resource.NonRetryableError(billErr)
    	}
    	// yunti prepaid user
    	if resourceId != nil {
    		id = *resourceId
    		return nil
    	}
    }
  normal: |
    // normal user
    if !billingService.IsYunTiAccount() {
    	id = *dealRes.Response.BillingResourceInfos[0].ClusterId
    }
  setTag: |
    // set tag before query the instance
    	if tags := helper.GetTags(d, "tags"); len(tags) > 0 {
    		resourceName := tccommon.BuildTagResourceName("cynosdb", "cluster", region, id)
    		if err := tagService.ModifyTags(ctx, resourceName, tags, nil); err != nil {
    			return err
    		}

    		// Wait the tags enabled
    		err = tagService.WaitTagsEnable(ctx, "cynosdb", "cluster", id, region, tags)
    		if err != nil {
    			return err
    		}
    	}
  waitTag: |
    // Wait the tags enabled
    err := tagService.WaitTagsEnable(ctx, "cynosdb", "cluster", d.Id(), region, replaceTags)
    if err != nil {
    	return err
    }

tencentcloud/services/es/resource_tc_elasticsearch_instance.go:
  import: |
    import "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/services/billing"
  var: |
    var (
    	client               = meta.(tccommon.ProviderMeta).GetAPIV3Conn()
    	billingService       = billing.BillingService{Client: client}
    	tagService           = svctag.NewTagService(meta.(tccommon.ProviderMeta).GetAPIV3Conn())
    	region               = client.Region
    	chargeType           string
    )
  strCharge: "chargeType = v.(string)"
  reqTag: |
    var tags map[string]string
    	if tags = helper.GetTags(d, "tags"); len(tags) > 0 {
    		if billingService.IsYunTiAccount() {
    			request.TagList = make([]*es.TagInfo, 0, len(tags))
    			for k, v := range tags {
    				tagInfo := &es.TagInfo{
    					TagKey:   helper.String(k),
    					TagValue: helper.String(v),
    				}
    				request.TagList = append(request.TagList, tagInfo)
    			}
    		}
    	}
  bpass: |
    if chargeType == ES_CHARGE_TYPE_PREPAID {
    	regx := "\"dealNames\":\\\[\"(.*)\"\\\]"
    	// query deal by bpass
    	id, billErr := billingService.QueryDealByBpass(ctx, regx, err)
    	if billErr != nil {
    		log.Printf("[CRITAL]%s api[QueryDealByBpass] fail, reason[%s]\\n", logId, billErr.Error())
    		return resource.NonRetryableError(billErr)
    	}
    	// yunti prepaid user
    	if id != nil {
    		instanceId = *id
    		return nil
    	}
    }
  setTag: |
    // set tag before query the instance
    	if len(tags) > 0 {
    		// resourceName := fmt.Sprintf("qcs::es:%s:uin/:instance/%s", region, instanceId)
    		resourceName := tccommon.BuildTagResourceName("es", "instance", region, d.Id())
    		if err := tagService.ModifyTags(ctx, resourceName, tags, nil); err != nil {
    			return err
    		}

    		// Wait the tags enabled
    		err = tagService.WaitTagsEnable(ctx, "es", "instance", d.Id(), region, tags)
    		if err != nil {
    			return err
    		}
    	}
  waitTag: |
    // resourceName := fmt.Sprintf("qcs::es:%s:uin/:instance/%s", region, instanceId)
    resourceName := tccommon.BuildTagResourceName("es", "instance", region, d.Id())
    if err := tagService.ModifyTags(ctx, resourceName, replaceTags, deleteTags); err != nil {
    	return err
    }

    // Wait the tags enabled
    err := tagService.WaitTagsEnable(ctx, "es", "instance", d.Id(), region, replaceTags)

tencentcloud/services/mongodb/resource_tc_mongodb_instance.go:
  import: |
    import	sdkErrors "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/common/errors"
    import "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/services/billing"
  bpass: |
    // query deal by bpass
    e, ok := err.(*sdkErrors.TencentCloudSDKError)
    log.Printf("[DEBUG]%s query deal for PREPAID user, msg:[%s] \\n", logId, e.Error())

    if ok && tccommon.IsContains("InvalidParameterValue.InvalidTradeOperation", e.Code) {
    	// yunti prepaid user
    	return tccommon.RetryError(fmt.Errorf("[DEBUG] wait pass the bpass for yunti prepaid user, retry... error msg:[%s]", e.Message))
    }

    // if id != nil {
    // 	// yunti prepaid user
    // 	resourceId = *id
    // 	return nil
    // }
  setTag: |
    // set tag before query the instance
    	if tags := helper.GetTags(d, "tags"); len(tags) > 0 {
    		resourceName := tccommon.BuildTagResourceName("mongodb", "instance", region, instanceId)
    		if err := tagService.ModifyTags(ctx, resourceName, tags, nil); err != nil {
    			return err
    		}

    		// Wait the tags enabled
    		err := tagService.WaitTagsEnable(ctx, "mongodb", "instance", instanceId, region, tags)
    		if err != nil {
    			return err
    		}
    	}

tencentcloud/services/cdb/resource_tc_mysql_instance.go:
  import: |
    import "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/services/billing"
  var: |
    client := meta.(tccommon.ProviderMeta).GetAPIV3Conn()
    billingService := billing.BillingService{Client: client}
    var instanceId string
  bpass: |
    // query deal by bpass
    regx := "dealNames:\\\[\"(.*)\"\\\]\\\],"
    id, billErr := billingService.QueryDealByBpass(ctx, regx, inErr)
    if billErr != nil {
    log.Printf("[CRITAL]%s api[DescribeDeals] fail, reason[%s]\\n", logId, billErr.Error())
    return resource.NonRetryableError(billErr)
    }
    // yunti prepaid user
    if id != nil {
    instanceId = *id
    return nil
    }
  instanceId: "instanceId = *response.Response.InstanceIds[0]"
  setId: "d.SetId(instanceId)"
  mysqlServer: |
    client := meta.(tccommon.ProviderMeta).GetAPIV3Conn()
    mysqlService := MysqlService{client: client}
    tagService := svctag.NewTagService(meta.(tccommon.ProviderMeta).GetAPIV3Conn())
  setTag: |
    // set tag before query the instance
    	if tags := helper.GetTags(d, "tags"); len(tags) > 0 {
    		resourceName := tccommon.BuildTagResourceName("cdb", "instanceId", client.Region, d.Id())
    		if err := tagService.ModifyTags(ctx, resourceName, tags, nil); err != nil {
    			return err
    		}

    		// Wait the tags enabled
    		err := tagService.WaitTagsEnable(ctx, "cdb", "instanceId", d.Id(), client.Region, tags)
    		if err != nil {
    			return err
    		}
    		// wait for describe enable
    		time.Sleep(3 * time.Second)
        }
  waitTag:
    // Wait the tags enabled
    err = tagService.WaitTagsEnable(ctx, "cdb", "instanceId", d.Id(), region, replaceTags)
    if err != nil {
    return err
    }

tencentcloud/services/postgresql/resource_tc_postgresql_instance.go:
  import: |
    import "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/services/billing"
  clientCreate: |
    client := meta.(tccommon.ProviderMeta).GetAPIV3Conn()
    postgresqlService := PostgresqlService{client: client}
    tagService := svctag.NewTagService(meta.(tccommon.ProviderMeta).GetAPIV3Conn())
    billingService := billing.BillingService{Client: client}
    region := client.Region
  var: "chargeType     = d.Get(\"charge_type\").(string)"
  bpass: |
    log.Printf("[CRITAL]%s api[%s] fail, reason:%s", logId, "CreatePostgresqlInstance", inErr.Error())

    if chargeType == COMMON_PAYTYPE_PREPAID {
    regx := "\"dealNames\":\\\[\"(.*)\"\\\]"
    // query deal by bpass
    id, billErr := billingService.QueryDealByBpass(ctx, regx, inErr)
    if billErr != nil {
    	log.Printf("[CRITAL]%s api[QueryDealByBpass] fail, reason[%s]\\n", logId, billErr.Error())
    	return resource.NonRetryableError(billErr)
    }
    // yunti prepaid user
    if id != nil {
    	instanceId = *id
    	return nil
    }
    }
  setTag: |
    // set tag before query the instance
    if tags := helper.GetTags(d, "tags"); len(tags) > 0 {
    resourceName := tccommon.BuildTagResourceName("postgres", "DBInstanceId", region, d.Id())
    if err := tagService.ModifyTags(ctx, resourceName, tags, nil); err != nil {
    return err
    }

    // Wait the tags enabled
    err := tagService.WaitTagsEnable(ctx, "postgres", "DBInstanceId", d.Id(), region, tags)
    if err != nil {
    return err
    }
    }
  clientUpdate: |
    tcClient := meta.(tccommon.ProviderMeta).GetAPIV3Conn()
    tagService := svctag.NewTagService(meta.(tccommon.ProviderMeta).GetAPIV3Conn())
    postgresqlService := PostgresqlService{client: tcClient}
  waitTag: |
    // Wait the tags enabled
    		err = tagService.WaitTagsEnable(ctx, "postgres", "DBInstanceId", d.Id(), tcClient.Region, replaceTags)
    		if err != nil {
    			return err
    		}


tencentcloud/services/tag/service_tencentcloud_tag.go:
  import: |
    import "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/services/billing"
    import "fmt"
  waitTag: |
    func (me *TagService) WaitTagsEnable(ctx context.Context, serviceType, resType, resId, region string, tags map[string]string) (retErr error) {
    billingService := billing.BillingService{Client: me.client}
      if !billingService.IsYunTiAccount() {
        return nil
      }
      retErr = resource.Retry(3*tccommon.ReadRetryTimeout, func() *resource.RetryError {
      ret, err := me.DescribeResourceTags(ctx, serviceType, resType, region, resId)
        if err != nil {
          return tccommon.RetryError(err)
        }
        if ret != nil {
          if tagEqual(ret, tags) {
            return nil
          }
        return resource.RetryableError(fmt.Errorf("the redis.instance %s is uncomplete, retry ...", resId))
        }
        return resource.RetryableError(fmt.Errorf("the redis.instance %s's tags is nil, retry ...", resId))
        })
      return retErr
    }

    func tagEqual(dst, orig map[string]string) bool {
      for k := range orig {
        if dst[k] == "" {
          return false
        }
        if dst[k] != orig[k] {
          return false
        }
      }
      return true
    }
tencentcloud/services/billing/service_tencentcloud_billing.go:
  all: |
    package billing
  
    import (
    "context"
    "fmt"
    "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud"
    tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
    "log"
    "os"
    "regexp"
    "strings"
    "time"
    
    "github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
    "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
    "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/ratelimit"
    
    billingSdk "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/billing/v20180709"
    sdkErrors "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/common/errors"
    "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/connectivity"
    )
      
    type BillingService struct {
      Client *connectivity.TencentCloudClient
    }
      
    func (me *BillingService) DescribeDeals(ctx context.Context, dealId string) (deal *billingSdk.Deal, errRet error) {
      var (
      logId    = tccommon.GetLogId(ctx)
      request  = billingSdk.NewDescribeDealsByCondRequest()
      response = billingSdk.NewDescribeDealsByCondResponse()
      dealList []*billingSdk.Deal
      )
      
      defer func() {
      if errRet != nil {
      log.Printf("[CRITAL]%s api[%s] fail, request body [%s], reason[%s]\\n",
      logId, "query object", request.ToJsonString(), errRet.Error())
    }
    }()
      
    request.OrderId = helper.String(dealId)
    request.Limit = helper.IntInt64(20)
    baseTime := time.Now().Local()
    startTime := baseTime.AddDate(0, 0, -7).Format("2006-01-02 15:04:05")
    endTime := baseTime.Format("2006-01-02 15:04:05")
    request.StartTime = helper.String(startTime)
    request.EndTime = helper.String(endTime)
      
    ratelimit.Check(request.GetAction())
    err := resource.Retry(20*tccommon.ReadRetryTimeout, func() *resource.RetryError {
      for _, dealState := range DEAL_STATUS_CODE {
      request.Status = helper.Int64(dealState)
      response, ee := me.Client.UseBillingClient().DescribeDealsByCond(request)
      if ee != nil {
      return tccommon.RetryError(errRet, tccommon.InternalError)
      }
      dealList = response.Response.Deals
      if len(dealList) > 0 {
      break
      }
    }
    if len(dealList) != 1 {
      log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\\n",
      logId, request.GetAction(), request.ToJsonString(), response.ToJsonString())
      return nil
    }
      deal = dealList[0]
    if in(*deal.Status, DEAL_TERMINATE_STATUS_CODE) {
      log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\\n",
      logId, request.GetAction(), request.ToJsonString(), response.ToJsonString())
      return nil
    }
      time.Sleep(3 * time.Second)
    return resource.RetryableError(fmt.Errorf("deal status is not ready..., current is: %v", deal.Status))
    })
      
    if err != nil {
      errRet = err
      return
    }
      return
    }
      
    func (me *BillingService) IsYunTiAccount() bool {
      val, ok := os.LookupEnv(tencentcloud.PROVIDER_ENABLE_YUNTI)
      if ok && strings.ToLower(val) == "true" {
      return true
    }
      return false
    }
      
      //query deal by bpass
    func (me *BillingService) QueryDealByBpass(ctx context.Context, dealRegx string, msg error) (resourceId *string, err error) {
      logId := tccommon.GetLogId(ctx)
      
      if !me.IsYunTiAccount() {
      return
    }
      
      e, ok := msg.(*sdkErrors.TencentCloudSDKError)
      log.Printf("[DEBUG]%s query deal for PREPAID user, msg:[%s] \\n", logId, e.Error())
      
      if ok && tccommon.tccommon.IsContains(TRADE_RETRYABLE_ERROR, e.Code) {
      errStr := msg.Error()
      
      re := regexp.MustCompile(dealRegx)
      result := re.FindStringSubmatch(errStr)
      for i, str := range result {
      log.Printf("[DEBUG] FindStringSubmatch sub[%v]:%s,\\n", i, str)
    }
      dealId := re.FindStringSubmatch(errStr)[1]
      deal, billErr := me.DescribeDeals(ctx, dealId)
    if billErr != nil {
      log.Printf("[CRITAL]%s api[DescribeDeals] fail, reason[%s]\\n", logId, billErr.Error())
      return nil, billErr
    }
      resourceId = deal.ResourceId[0]
      log.Printf("[DEBUG]%s query deal for PREPAID user succeed, dealId:[%s] resourceId:[%s]\\n", logId, dealId, *resourceId)
      return resourceId, nil
    }
      return
    }
      
    func in(target int64, intArr []int64) bool {
      for _, element := range intArr {
      if target == element {
      return true
    }
    }
      return false
    }

go.mod: |
  require (
  github.com/hashicorp/terraform-plugin-sdk v1.7.0
  github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/billing v1.0.809
  )


tencentcloud/services/crs/resource_tc_redis_instance.go:
  import: |
    import	"time"
    import	sdkErrors "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/common/errors"
    import "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/services/billing"
  tagComputed: "				Computed:    true,"
  clientCreate: "	billingService := billing.BillingService{Client: client}"
  redisServer: "		masterZoneId, err := redisService.getZoneId(availabilityZone)"
  varId: "var resourceId string"
  bpass: |
    log.Printf("[CRITAL]%s api[CreateInstances] fail, reason[%s]\\n", logId, err.Error())

    if chargeType == REDIS_CHARGE_TYPE_PREPAID {
        regx := "\"dealNames\":\\\[\"(.*)\"\\\]" // dealNames:\["(.*)"\]
        // query deal by bpass
        id, inErr := billingService.QueryDealByBpass(ctx, regx, err)
        if inErr != nil {
            return inErr
        }
        // yunti prepaid user
        if id != nil {
            resourceId = *id
        }
    } else {
        return err
    }
  getId: |
    // normal user
    if !billingService.IsYunTiAccount() || chargeType == REDIS_CHARGE_TYPE_POSTPAID {
    resourceId = *instanceIds[0]
    }
  setTag: |
    // set tag before query the instance
    	if tags := helper.GetTags(d, "tags"); len(tags) > 0 {
    		log.Printf("[DEBUG]%s begin to modify tags, len(tags):[%v], tags:[%s]\\n", logId, len(tags), tags)
    		for k, v := range tags {
    			log.Printf("[DEBUG]%s tags[k:%s, v:%s]", logId, k, v)
    		}
    		resourceName := tccommon.BuildTagResourceName("redis", "instance", region, resourceId)
    		if err := tagService.ModifyTags(ctx, resourceName, tags, nil); err != nil {
    			log.Printf("[CRITAL]%s modify tags failed, reason:%s\\n", logId, err.Error())
    			return err
    		}

    		// Wait the tags enabled
    		err = tagService.WaitTagsEnable(ctx, "redis", "instance", resourceId, region, tags)
    		if err != nil {
    			return err
    		}
    		// wait for describe enable
    		time.Sleep(3 * time.Second)
    	}
  clientRead: |
    tcClient := meta.(tccommon.ProviderMeta).GetAPIV3Conn()
    service := RedisService{client: tcClient}
    tagService := svctag.NewTagService(meta.(tccommon.ProviderMeta).GetAPIV3Conn())

    instanceId := d.Id()
  redisFail: |
    log.Printf("[WARN]%s resource `tencentcloud_redis_instance` [%s] not found, please check if it has been deleted.", logId, instanceId)
    return nil
  resourceTag: |
    var tags map[string]string
    tags, err = tagService.DescribeResourceTags(ctx, "redis", "instance", tcClient.Region, instanceId)
  setTagUpdate: "resourceName := tccommon.BuildTagResourceName(\"redis\", \"instance\", region, d.Id())"
  waitTag: |
    // Wait the tags enabled
    err := tagService.WaitTagsEnable(ctx, "redis", "instance", d.Id(), region, replaceTags)
    if err != nil {
    	return err
    }
  queryAndSetId: |
    _, _, _, err = redisService.CheckRedisOnlineOk(ctx, resourceId, 20*tccommon.ReadRetryTimeout)
  
    if err != nil {
    log.Printf("[CRITAL]%s create redis task fail, reason:%s\\n", logId, err.Error())
      return err
    }
  
    d.SetId(resourceId)

tencentcloud/services/tpulsar/resource_tc_tdmq_instance.go:
  import: |
    import "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/services/tag"
  client: |
    client := meta.(tccommon.ProviderMeta).GetAPIV3Conn()
    tagService := svctag.NewTagService(meta.(tccommon.ProviderMeta).GetAPIV3Conn())
    region := client.Region
  buildName: "resourceName := tccommon.BuildTagResourceName(\"tdmq\", \"cluster\", region, clusterId)"
  waitTag: |
    // Wait the tags enabled
    		err = tagService.WaitTagsEnable(ctx, "tdmq", "cluster", clusterId, region, tags)
    		if err != nil {
    			return err
    		}
  var: |
    tagService := TagService{client: meta.(tccommon.ProviderMeta).GetAPIV3Conn()}
    region := meta.(tccommon.ProviderMeta).GetAPIV3Conn().Region
  setTag: |
    oldTags, newTags := d.GetChange("tags")
    replaceTags, deleteTags := diffTags(oldTags.(map[string]interface{}), newTags.(map[string]interface{}))
    resourceName := tccommon.BuildTagResourceName("tdmq", "cluster", region, d.Id())
    if err := tagService.ModifyTags(ctx, resourceName, replaceTags, deleteTags); err != nil {
      return err
    }
    
    
    // Wait the tags enabled
    err := tagService.WaitTagsEnable(ctx, "tdmq", "cluster", d.Id(), region, replaceTags)
    if err != nil {
      return err
    }