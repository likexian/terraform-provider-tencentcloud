tencentcloud/connectivity/client.go:
  import: "import billing \"github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/billing/v20180709\""
  client: "billingConn        *billing.Client"
  useClient: |
    func (me *TencentCloudClient) UseBillingClient() *billing.Client {
        if me.billingConn != nil {
          return me.billingConn
        }

        cpf := me.NewClientProfile(300)
        me.billingConn, _ = billing.NewClient(me.Credential, me.Region, cpf)
        me.billingConn.WithHttpTransport(&LogRoundTripper{})

        return me.billingConn
    }

tencentcloud/extension_billing.go:
  all: |
    package tencentcloud

    var TRADE_RETRYABLE_ERROR = []string{
      "InternalError.TradeError",  //mysql
      "FailedOperation.PayFailed", //redis
    }

    // deal status: https://cloud.tencent.com/document/product/555/19179

    var DEAL_STATUS_CODE = []int64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}

    var DEAL_TERMINATE_STATUS_CODE = []int64{4, 5, 6, 7, 8, 9, 10, 11}

tencentcloud/internal/helper/transform.go:
  boolStr: |
    func BoolToStr(b bool) (s string) {
      s = "false"
      if b {
        s = "true"
      }
      return
    }
tencentcloud/provider.go:
  envYunti: "	PROVIDER_ENABLE_YUNTI                 = \"TENCENTCLOUD_ENABLE_YUNTI\""
  enableBpass: |
    "enable_bpass": {
    Type:        schema.TypeBool,
    Optional:    true,
    Default:     false,
    DefaultFunc: schema.EnvDefaultFunc(PROVIDER_ENABLE_YUNTI, nil),
    Description: "Use the yunti account or not, Default is `false`.",
    },
tencentcloud/resource_tc_cynosdb_cluster.go:
  client: |
    billingService = BillingService{client: client}
  varId: "	var id string"
  varCharge: "	var chargeTypeStr string"
  strCharge: "		chargeTypeStr = v.(string)"
  byPass: |
    if chargeTypeStr == CYNOSDB_CHARGE_TYPE_PREPAID {
    	regx := "\"dealNames\":\\[\"(.*)\"\\]"
    	// query deal by bpass
    	resourceId, billErr := billingService.QueryDealByBpass(ctx, regx, err)
    	if billErr != nil {
    		log.Printf("[CRITAL]%s api[QueryDealByBpass] fail, reason[%s]\n", logId, billErr.Error())
    		return resource.NonRetryableError(billErr)
    	}
    	// yunti prepaid user
    	if resourceId != nil {
    		id = *resourceId
    		return nil
    	}
    }
  normal: |
    // normal user
    if !billingService.isYunTiAccount() {
    	id = *dealRes.Response.BillingResourceInfos[0].ClusterId
    }
  setTag: |
    // set tag before query the instance
    	if tags := helper.GetTags(d, "tags"); len(tags) > 0 {
    		resourceName := BuildTagResourceName("cynosdb", "cluster", region, id)
    		if err := tagService.ModifyTags(ctx, resourceName, tags, nil); err != nil {
    			return err
    		}

    		// Wait the tags enabled
    		err = tagService.waitTagsEnable(ctx, "cynosdb", "cluster", id, region, tags)
    		if err != nil {
    			return err
    		}
    	}
  waitTag: |
    // Wait the tags enabled
    err := tagService.waitTagsEnable(ctx, "cynosdb", "cluster", d.Id(), region, replaceTags)
    if err != nil {
    	return err
    }

tencentcloud/resource_tc_elasticsearch_instance.go:
  var: |
    var (
    	client               = meta.(*TencentCloudClient).apiV3Conn
    	elasticsearchService = ElasticsearchService{client: client}
    	billingService       = BillingService{client: client}
    	tagService           = TagService{client: client}
    	region               = client.Region
    	chargeType           string

    	request = es.NewCreateInstanceRequest()
    )
  strCharge: "chargeType = v.(string)"
  reqTag: |
    var tags map[string]string
    	if tags = helper.GetTags(d, "tags"); len(tags) > 0 {
    		if billingService.isYunTiAccount() {
    			request.TagList = make([]*es.TagInfo, 0, len(tags))
    			for k, v := range tags {
    				tagInfo := &es.TagInfo{
    					TagKey:   helper.String(k),
    					TagValue: helper.String(v),
    				}
    				request.TagList = append(request.TagList, tagInfo)
    			}
    		}
    	}
  bypass: |
    if chargeType == ES_CHARGE_TYPE_PREPAID {
    	regx := "\"dealNames\":\\\[\"(.*)\"\\\]"
    	// query deal by bpass
    	id, billErr := billingService.QueryDealByBpass(ctx, regx, err)
    	if billErr != nil {
    		log.Printf("[CRITAL]%s api[QueryDealByBpass] fail, reason[%s]\\n", logId, billErr.Error())
    		return resource.NonRetryableError(billErr)
    	}
    	// yunti prepaid user
    	if id != nil {
    		instanceId = *id
    		return nil
    	}
    }
  setTag: |
    // set tag before query the instance
    	if len(tags) > 0 {
    		// resourceName := fmt.Sprintf("qcs::es:%s:uin/:instance/%s", region, instanceId)
    		resourceName := BuildTagResourceName("es", "instance", region, d.Id())
    		if err := tagService.ModifyTags(ctx, resourceName, tags, nil); err != nil {
    			return err
    		}

    		// Wait the tags enabled
    		err = tagService.waitTagsEnable(ctx, "es", "instance", d.Id(), region, tags)
    		if err != nil {
    			return err
    		}
    	}
  waitTag: |
    // resourceName := fmt.Sprintf("qcs::es:%s:uin/:instance/%s", region, instanceId)
    resourceName := BuildTagResourceName("es", "instance", region, d.Id())
    if err := tagService.ModifyTags(ctx, resourceName, replaceTags, deleteTags); err != nil {
    	return err
    }

    // Wait the tags enabled
    err := tagService.waitTagsEnable(ctx, "es", "instance", d.Id(), region, replaceTags)

tencentcloud/resource_tc_mongodb_instance.go:
  import: "import	sdkErrors \"github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/common/errors\""
  bpass: |
    // query deal by bpass
    e, ok := err.(*sdkErrors.TencentCloudSDKError)
    log.Printf("[DEBUG]%s query deal for PREPAID user, msg:[%s] \n", logId, e.Error())

    if ok && IsContains("InvalidParameterValue.InvalidTradeOperation", e.Code) {
    	// yunti prepaid user
    	return retryError(fmt.Errorf("[DEBUG] wait pass the bpass for yunti prepaid user, retry... error msg:[%s]", e.Message))
    }

    // if id != nil {
    // 	// yunti prepaid user
    // 	resourceId = *id
    // 	return nil
    // }
  setTag: |
    // set tag before query the instance
    	if tags := helper.GetTags(d, "tags"); len(tags) > 0 {
    		resourceName := BuildTagResourceName("mongodb", "instance", region, instanceId)
    		if err := tagService.ModifyTags(ctx, resourceName, tags, nil); err != nil {
    			return err
    		}

    		// Wait the tags enabled
    		err := tagService.waitTagsEnable(ctx, "mongodb", "instance", instanceId, region, tags)
    		if err != nil {
    			return err
    		}
    	}

tencentcloud/resource_tc_mysql_instance.go:
  var: |
    client := meta.(*TencentCloudClient).apiV3Conn
    billingService := BillingService{client: client}
    var instanceId string
  bpass: |
    // query deal by bpass
    regx := "dealNames:\\[\"(.*)\"\\]\\],"
    id, billErr := billingService.QueryDealByBpass(ctx, regx, inErr)
    if billErr != nil {
    log.Printf("[CRITAL]%s api[DescribeDeals] fail, reason[%s]\n", logId, billErr.Error())
    return resource.NonRetryableError(billErr)
    }
    // yunti prepaid user
    if id != nil {
    instanceId = *id
    return nil
    }
  instanceId: "instanceId = *response.Response.InstanceIds[0]"
  setId: "d.SetId(instanceId)"
  mysqlServer: |
    client := meta.(*TencentCloudClient).apiV3Conn
    mysqlService := MysqlService{client: client}
    tagService := &TagService{client: client}
  setTag: |
    // set tag before query the instance
    	if tags := helper.GetTags(d, "tags"); len(tags) > 0 {
    		resourceName := BuildTagResourceName("cdb", "instanceId", client.Region, d.Id())
    		if err := tagService.ModifyTags(ctx, resourceName, tags, nil); err != nil {
    			return err
    		}

    		// Wait the tags enabled
    		err := tagService.waitTagsEnable(ctx, "cdb", "instanceId", d.Id(), client.Region, tags)
    		if err != nil {
    			return err
    		}
    		// wait for describe enable
    		time.Sleep(3 * time.Second)
        }
  waitTag:
    // Wait the tags enabled
    err = tagService.waitTagsEnable(ctx, "cdb", "instanceId", d.Id(), region, replaceTags)
    if err != nil {
    return err
    }

tencentcloud/resource_tc_postgresql_instance.go:
  clientCreate: |
    client := meta.(*TencentCloudClient).apiV3Conn
    postgresqlService := PostgresqlService{client: client}
    tagService := TagService{client: client}
    billingService := BillingService{client: client}
    region := client.Region
  var: "chargeType     = d.Get(\"charge_type\").(string)"
  bypass: |
    log.Printf("[CRITAL]%s api[%s] fail, reason:%s", logId, "CreatePostgresqlInstance", inErr.Error())

    if chargeType == COMMON_PAYTYPE_PREPAID {
    regx := "\"dealNames\":\\[\"(.*)\"\\]"
    // query deal by bpass
    id, billErr := billingService.QueryDealByBpass(ctx, regx, inErr)
    if billErr != nil {
    	log.Printf("[CRITAL]%s api[QueryDealByBpass] fail, reason[%s]\n", logId, billErr.Error())
    	return resource.NonRetryableError(billErr)
    }
    // yunti prepaid user
    if id != nil {
    	instanceId = *id
    	return nil
    }
    }
  setTag: |
    // set tag before query the instance
    if tags := helper.GetTags(d, "tags"); len(tags) > 0 {
    resourceName := BuildTagResourceName("postgres", "DBInstanceId", region, d.Id())
    if err := tagService.ModifyTags(ctx, resourceName, tags, nil); err != nil {
    return err
    }

    // Wait the tags enabled
    err := tagService.waitTagsEnable(ctx, "postgres", "DBInstanceId", d.Id(), region, tags)
    if err != nil {
    return err
    }
    }
  clientUpdate: |
    tcClient := meta.(*TencentCloudClient).apiV3Conn
    tagService := &TagService{client: tcClient}
    postgresqlService := PostgresqlService{client: tcClient}
  waitTag: |
    // Wait the tags enabled
    		err = tagService.waitTagsEnable(ctx, "postgres", "DBInstanceId", d.Id(), tcClient.Region, replaceTags)
    		if err != nil {
    			return err
    		}


tencentcloud/service_tencentcloud_tag.go:
  tagFmt: "import \"fmt\""
  waitTag: |
    func (me *TagService) waitTagsEnable(ctx context.Context, serviceType, resType, resId, region string, tags map[string]string) (retErr error) {
    billingService := BillingService{client: me.client}
      if !billingService.isYunTiAccount() {
        return nil
      }
      retErr = resource.Retry(3*readRetryTimeout, func() *resource.RetryError {
      ret, err := me.DescribeResourceTags(ctx, serviceType, resType, region, resId)
        if err != nil {
          return retryError(err)
        }
        if ret != nil {
          if tagEqual(ret, tags) {
            return nil
          }
        return resource.RetryableError(fmt.Errorf("the redis.instance %s is uncomplete, retry ...", resId))
        }
        return resource.RetryableError(fmt.Errorf("the redis.instance %s's tags is nil, retry ...", resId))
        })
      return retErr
    }

    func tagEqual(dst, orig map[string]string) bool {
      for k := range orig {
        if dst[k] == "" {
          return false
        }
        if dst[k] != orig[k] {
          return false
        }
      }
      return true
    }
#
tencentcloud/service_tencentcloud_billing.go:
  all: |
    package tencentcloud

    import (
    "context"
    "fmt"
    "log"
    "os"
    "regexp"
    "strings"
    "time"

    "github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
    "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
    "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/ratelimit"

    billing "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/billing/v20180709"
    sdkErrors "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/common/errors"
    "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/connectivity"
    )

      type BillingService struct {
      client *connectivity.TencentCloudClient
    }

      func (me *BillingService) DescribeDeals(ctx context.Context, dealId string) (deal *billing.Deal, errRet error) {
      var (
      logId    = getLogId(ctx)
      request  = billing.NewDescribeDealsByCondRequest()
      response = billing.NewDescribeDealsByCondResponse()
      dealList []*billing.Deal
      )

      defer func() {
      if errRet != nil {
      log.Printf("[CRITAL]%s api[%s] fail, request body [%s], reason[%s]\n",
      logId, "query object", request.ToJsonString(), errRet.Error())
    }
    }()

      request.OrderId = helper.String(dealId)
      request.Limit = helper.IntInt64(20)
      baseTime := time.Now().Local()
      startTime := baseTime.AddDate(0, 0, -7).Format("2006-01-02 15:04:05")
      endTime := baseTime.Format("2006-01-02 15:04:05")
      request.StartTime = helper.String(startTime)
      request.EndTime = helper.String(endTime)

      ratelimit.Check(request.GetAction())
      err := resource.Retry(20*readRetryTimeout, func() *resource.RetryError {
      for _, dealState := range DEAL_STATUS_CODE {
      request.Status = helper.Int64(dealState)
      response, ee := me.client.UseBillingClient().DescribeDealsByCond(request)
      if ee != nil {
      return retryError(errRet, InternalError)
      }
      dealList = response.Response.Deals
      if len(dealList) > 0 {
      break
      }
    }
      if len(dealList) != 1 {
      log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n",
      logId, request.GetAction(), request.ToJsonString(), response.ToJsonString())
      return nil
    }
      deal = dealList[0]
      if in(*deal.Status, DEAL_TERMINATE_STATUS_CODE) {
      log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n",
      logId, request.GetAction(), request.ToJsonString(), response.ToJsonString())
      return nil
    }
      time.Sleep(3 * time.Second)
    return resource.RetryableError(fmt.Errorf("deal status is not ready..., current is: %v", deal.Status))
    })

      if err != nil {
      errRet = err
      return
    }
      return
    }

      func (me *BillingService) isYunTiAccount() bool {
      val, ok := os.LookupEnv(PROVIDER_ENABLE_YUNTI)
      if ok && strings.ToLower(val) == "true" {
      return true
    }
      return false
    }

      //query deal by bpass
      func (me *BillingService) QueryDealByBpass(ctx context.Context, dealRegx string, msg error) (resourceId *string, err error) {
      logId := getLogId(ctx)

      if !me.isYunTiAccount() {
      return
    }

      e, ok := msg.(*sdkErrors.TencentCloudSDKError)
      log.Printf("[DEBUG]%s query deal for PREPAID user, msg:[%s] \n", logId, e.Error())

      if ok && IsContains(TRADE_RETRYABLE_ERROR, e.Code) {
      errStr := msg.Error()

      re := regexp.MustCompile(dealRegx)
      result := re.FindStringSubmatch(errStr)
      for i, str := range result {
      log.Printf("[DEBUG] FindStringSubmatch sub[%v]:%s,\n", i, str)
    }
      dealId := re.FindStringSubmatch(errStr)[1]
      deal, billErr := me.DescribeDeals(ctx, dealId)
      if billErr != nil {
      log.Printf("[CRITAL]%s api[DescribeDeals] fail, reason[%s]\n", logId, billErr.Error())
      return nil, billErr
    }
      resourceId = deal.ResourceId[0]
      log.Printf("[DEBUG]%s query deal for PREPAID user succeed, dealId:[%s] resourceId:[%s]\n", logId, dealId, *resourceId)
      return resourceId, nil
    }
      return
    }

      func in(target int64, intArr []int64) bool {
      for _, element := range intArr {
      if target == element {
      return true
    }
    }
      return false
    }

go.mod: |
  require (
  github.com/hashicorp/terraform-plugin-sdk v1.7.0
  github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/billing v1.0.809
  )